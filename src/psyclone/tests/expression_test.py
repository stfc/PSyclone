# -----------------------------------------------------------------------------
# BSD 3-Clause License
#
# Copyright (c) 2017-2024, Science and Technology Facilities Council.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
# Authors: R. W. Ford and A. R. Porter, STFC Daresbury Lab
# Modified by J. Henrichs, Bureau of Meteorology

''' Module containing tests for the Fortran expression parser '''

from psyclone.expression import (BinaryOperator, FunctionVar, Grouping,
                                 LiteralArray, NamedArg, Slicing,
                                 VAR_OR_FUNCTION, FORT_EXPRESSION, SLICING)


def my_test(name, parser, test_string, names=None):
    '''This function ensures that the parse-unparse and parse-repr-unparse
    operations are equivalent to the identity. Note that whitespace is not
    preserved by the parsing operation, so the test_string must conform to
    the whitespace conventions of the unparser for the test to succeed.'''

    pstr = parser.parseString(test_string)
    assert (str(pstr[0]) == test_string), "Failed to parse " + name + "."
    # ast.literal_eval can't be used here as the generated expression
    # calls constructors of user-defined objects

    context = {
        'BinaryOperator': BinaryOperator,
        'FunctionVar': FunctionVar,
        'Grouping': Grouping,
        'LiteralArray': LiteralArray,
        'NamedArg': NamedArg,
        'Slicing': Slicing,
    }
    # pylint: disable=exec-used
    exec("pstr="+repr(pstr[0]), context)
    pstr = context['pstr']

    assert (str(pstr) == test_string), "Error in repr for " + name + "."
    if names:
        assert pstr.names == set(names), "Names do not match for " + name + "."
    # Return the object created by the parser so that more specific checks
    # can be performed
    return pstr


def test_function_calls():
    ''' Test parsing of expressions containing function calls '''
    my_test("function calls",
            VAR_OR_FUNCTION, "foo(bar(baz, bam), wibble(wub))",
            names=["foo", "bar", "baz", "bam", "wibble", "wub"])


def test_no_args_function_call():
    ''' Test parsing of a function call with no arguments '''
    my_test("function call without args",
            VAR_OR_FUNCTION, "get_something()",
            names=["get_something"])


def test_trivial_slice():
    ''' Test parsing of simplest possible array slice '''
    my_test("trivial slice", SLICING, ":")


def test_simple_slice():
    ''' Test parsing of array slice with range and stride '''
    my_test("simple slice", SLICING, "1:2:3")


def test_stride_slice():
    ''' Test parsing of slice consisting of stride only '''
    my_test("stride slice", SLICING, "::3")


def test_exponent():
    ''' Test parsing of exponents '''
    my_test("exponent", FORT_EXPRESSION, "2 ** 3 ** 4")


def test_plus_mult():
    ''' Test parsing of expression containing addition and multiplication '''
    my_test("plus mult",
            FORT_EXPRESSION,
            "f(x) + g(x, y) * 2",
            names=["f", "g", "x", "y"])


def test_group():
    ''' Test parsing of a grouped expression (i.e. within parentheses) '''
    my_test("group", FORT_EXPRESSION, "(x)", names="x")


def test_integer():
    ''' Test parsing of an integer '''
    my_test("integer with kind", FORT_EXPRESSION, "-500")


def test_integer_kind():
    ''' Test parsing of an integer with kind specified '''
    my_test("integer with kind", FORT_EXPRESSION, "5_i_def")


def test_integer_kind_digits():
    ''' Test parsing of an integer with kind specified using digits only'''
    my_test("integer with kind digits", FORT_EXPRESSION, "5_16")


def test_real():
    ''' Test parsing of a real scalar '''
    my_test("real", FORT_EXPRESSION, "-.5e-200")


def test_real_kind():
    ''' Test parsing of a real scalar with kind specified'''
    my_test("real with kind", FORT_EXPRESSION, "-.5e-200_r_def")


def test_real_no_exp_kind():
    ''' Test parsing of a real scalar with no exponent but with kind
    specified '''
    my_test("no exponent real with kind", FORT_EXPRESSION, "-.5_r_def")


def test_real_kind_digits():
    ''' Test parsing of a real scalar with kind specified using digits only'''
    my_test("real with kind", FORT_EXPRESSION, "-.5e-200_32")


def test_group_operations():
    ''' Test parsing of a group of operations '''
    my_test("group operations",
            FORT_EXPRESSION,
            "(f(x + 2 * y, z:z + 2 + -.5) + (g + h) ** (z - 2))",
            names=["f", "g", "h", "x", "y", "z"])


def test_literal_array():
    ''' Test parsing of a literal array '''
    lit = my_test("literal array",
                  FORT_EXPRESSION,
                  "[1, 2, 3]")
    assert lit[0] == '1'
    assert lit[1] == '2'
    assert lit[2] == '3'
    assert len(lit) == 3


def test_named_int_arg():
    ''' Test parsing of a named, integer argument '''
    my_test("named int arg", FORT_EXPRESSION, "my_arg=2")


def test_named_logical_arg():
    ''' Test parsing of a named, logical argument '''
    named_arg = my_test("named logical arg", FORT_EXPRESSION,
                        "my_arg=.true.", names=["my_arg"])
    assert named_arg.value == ".true."
    assert named_arg.name == "my_arg"
    assert named_arg.is_string is False


def test_named_real_arg():
    ''' Test parsing of a named, real argument '''
    named_arg = my_test("named real arg", FORT_EXPRESSION, "my_arg=-2.0E3",
                        names=["my_arg"])
    assert named_arg.value == "-2.0E3"


def test_named_str_arg_single_quotes():
    ''' Test parsing a named string argument specified using single
    quotes '''
    named_arg = my_test("named arg single quotes", FORT_EXPRESSION,
                        "my_arg='funny'", names=["my_arg"])
    assert named_arg.value == "funny"
    assert named_arg.is_string is True


def test_named_str_arg_dble_quotes():
    ''' Test parsing a named string argument specified using double
    quotes '''
    named_arg = my_test("named arg double quotes", FORT_EXPRESSION,
                        'my_arg="funny"', names=["my_arg"])
    assert named_arg.value == "funny"


def test_named_str_arg_spaces():
    ''' Test parsing a named string argument where the value contains a
    space '''
    named_arg = my_test("named arg string with space", FORT_EXPRESSION,
                        'my_arg="very funny"', names=["my_arg"])
    assert named_arg.value == "very funny"


def test_fn_call_named_arg():
    ''' Test parsing of an expression containing a function call with a
    named argument '''
    info = my_test("Fn call with named arg", FORT_EXPRESSION,
                   "f(x, y=3, z='hello')", names=["f", "x", "y", "z"])
    assert info.args[1].value == "3"
    assert info.args[2].value == "hello"


def test_named_arg_variable():
    ''' Test the parsing of a named argument where the value is the name
    of a variable rather than a constant. '''
    named_arg = my_test("named arg variable", FORT_EXPRESSION,
                        "name=this_invoke", names=["name"])
    assert named_arg.value == "this_invoke"


def test_derived_type_deref():
    ''' Test parsing of reference to a component of a derived type '''
    my_test("ref. to derived-type component",
            FORT_EXPRESSION,
            "field%ndf")


def test_type_bound_call_no_args():
    ''' Test parsing of call to a type-bound routine '''
    my_test("call to type-bound routine",
            FORT_EXPRESSION,
            "field%get_ndf()")


def test_type_bound_call():
    ''' Test parsing of call to a type-bound routine which takes arguments '''
    my_test("call to type-bound routine",
            FORT_EXPRESSION,
            "field%get_ndf(a, b)")


def test_type_bound_call_deref_arg():
    ''' Test parsing of call to a type-bound routine which takes arguments,
    one of which is specified as the component of a derived type. '''
    my_test("call to type-bound routine with derived-type arg",
            FORT_EXPRESSION,
            "field%get_ndf(a, b%c)")


def test_type_bound_call_type_bound_arg():
    ''' Test parsing of call to a type-bound routine which takes arguments,
    one of which is specified as the result of a type-bound procedure call '''
    my_test("call to type-bound routine with type-bound arg",
            FORT_EXPRESSION,
            "field%get_ndf(a, b%c())")


def test_derived_type_deref_arg():
    ''' Test parsing of reference to a component of a derived type passed
    as an argument to a function call '''
    my_test("ref. to derived-type component",
            FORT_EXPRESSION,
            "get_colour_map(a, field%ndf)")


def test_type_bound_call_as_arg():
    ''' Test parsing of function call where one of the arguments is
    obtained from a call to a type-bound procedure '''
    my_test("ref. to derived-type component",
            FORT_EXPRESSION,
            "get_colour_map(a, field%get_ndf())")
