

!-----------------------------------------------------------------------------
! Copyright (c) 2017-2024,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
! LICENCE.original is available from the Met Office Science Repository Service:
! https://code.metoffice.gov.uk/trac/lfric/browser/LFRic/trunk/LICENCE.original
!-------------------------------------------------------------------------------

! BSD 3-Clause License
!
! Copyright (c) 2020-2024, Science and Technology Facilities Council
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! -----------------------------------------------------------------------------
! Modified by J. Henrichs, Bureau of Meteorology


!> @brief Provides a partitioning class
!>
!> @details When instantiated, this module partitions the mesh for the
!> supported mesh types: bi-periodic plane and cubed sphere.
!> It provides a list of cells known to this partition. The order of the
!> list is as follows:
!> The cells that are wholly owned by the partition are followed by the cells
!> that might have dofs in the halo and then, the cells that form the
!> the halo. Finally, an extra halo depth of cells is generated, these are
!> called the ghost cells - they are not part of the partitioned domain, but
!> are required to fully describe the cells in the partitioned domain. The
!> first depth of halos are generated by applying a stencil to the owned
!> cells. Subsequent depths of halo are generated by applying the stencil to
!> the previous depth of halo cells

module partition_mod

  use global_mesh_base_mod, only : global_mesh_type => global_mesh_base_type
  use log_mod,         only : log_event,         &
                              LOG_LEVEL_ERROR
  use constants_mod,   only: i_def, i_halo_index, r_def, l_def, integer_type

  use mpi_mod,         only: generate_redistribution_map, get_mpi_datatype

  implicit none

  private

  public :: partitioner_cubedsphere, &
            partitioner_planar, &
            partitioner_cubedsphere_serial, &
            partitioner_interface

  type, public :: partition_type
    private
  ! The number of the MPI rank
    integer(i_def)              :: local_rank
  ! Total number of MPI ranks in this execution
    integer(i_def)              :: total_ranks
  ! A List of global cell ids known to this partition ordered with inner cells
  ! first followed by the edge cells and finally the halo cells ordered by
  ! depth of halo
    integer(i_def), allocatable :: global_cell_id( : )
  ! A list of the ranks that own all the cells known to this partition
  ! held in the order of cells in the <code>global_cell_id</code> array
    integer(i_def), allocatable :: cell_owner( : )
  ! The number of "inner" cells in the <code>global_cell_id</code> list -
  ! one entry for each depth of inner halo
    integer(i_def), allocatable :: num_inner( : )
  ! The index of the last "inner" cell in the <code>global_cell_id</code> list -
  ! one entry for each depth of inner halo
    integer(i_def), allocatable :: last_inner_cell( : )
  ! The depth to which inner halos are generated
    integer(i_def)              :: inner_depth
  ! The number of "edge" cells in the <code>global_cell_id</code> list
    integer(i_def)              :: num_edge
  ! The index of the last "edge" cell in the <code>global_cell_id</code> list
    integer(i_def)              :: last_edge_cell
  ! The number of "halo" cells in the <code>global_cell_id</code> list -
  ! one entry for each depth of halo
    integer(i_def), allocatable :: num_halo( : )
  ! The index of the last "halo" cell in the <code>global_cell_id</code> list -
  ! one entry for each depth of halo
    integer(i_def), allocatable :: last_halo_cell( : )
  ! The depth to which halos are generated
    integer(i_def)              :: halo_depth
  ! The number of "ghost" cells in the <code>global_cell_id</code> list
    integer(i_def)              :: num_ghost
  ! The total number of cells in the global domain
    integer(i_def)              :: global_num_cells
  ! Number of panels in the 3D mesh
    integer(i_def)              :: npanels

  contains

    procedure, public :: get_num_cells_in_layer
    procedure, public :: get_inner_depth
    procedure, public :: get_num_cells_inner
    procedure, public :: get_last_inner_cell
    procedure, public :: get_num_cells_edge
    procedure, public :: get_last_edge_cell
    procedure, public :: get_halo_depth
    procedure, public :: get_num_cells_halo
    procedure, public :: get_last_halo_cell
    procedure, public :: get_num_cells_ghost
    procedure, public :: get_num_panels_global_mesh
    procedure, public :: get_local_rank
    procedure, public :: get_total_ranks
    procedure, public :: get_cell_owner
    procedure, public :: get_gid_from_lid
    procedure, public :: get_lid_from_gid
    procedure, public :: partition_type_assign
    procedure, public :: clear

    final             :: partition_destructor

    generic :: assignment(=) => partition_type_assign

  end type partition_type

  interface partition_type
    module procedure partition_constructor
    module procedure partition_constructor_unit_test_data
  end interface

  interface
    !> @brief Partitions a global mesh.
    !>
    !> @param[in]  global_mesh  A global mesh object that describes the layout
    !>                          of the global mesh
    !> @param[out] num_panels  Number of panels in the 3D mesh.
    !> @param[in]  xproc  Number of processors along x-direction.
    !> @param[in]  yproc  Number of processors along y-direction.
    !> @param[in]  local_rank  Local MPI rank number.
    !> @param[in]  total_ranks  Total number of MPI ranks.
    !> @param[in] max_stencil_depth  The maximum depth of stencil that will be
    !>                               used with this partition
    !> @param[inout] global_cell_id  Holds the global IDs of all cells in
    !>                               local partition.
    !> @param[out] num_inner  Number of cells that are inner halo cells.
    !> @param[out] num_edge  Number of cells that are owned by the partition,
    !>                       but may have dofs that are also owned by halo
    !>                       cells.
    !> @param[out] num_halo  Number of cells that are halo cells.
    !> @param[out] num_ghost  Number of "ghost" cells. These are cells in an
    !>                        extra halo around the outermost actaul halo and
    !>                        are not in the partitioned domain, but are
    !>                        required to fully describe the cells in the
    !>                        partitioned domain.
    !>
    subroutine partitioner_interface( global_mesh, &
                                      num_panels, &
                                      xproc, &
                                      yproc, &
                                      local_rank, &
                                      total_ranks, &
                                      max_stencil_depth, &
                                      global_cell_id, &
                                      num_inner, &
                                      num_edge, &
                                      num_halo, &
                                      num_ghost )
      import :: global_mesh_type
      import :: i_def

      class(global_mesh_type), intent(in), pointer :: global_mesh

      integer(i_def), intent(out)                :: num_panels
      integer(i_def), intent(in)                 :: xproc, yproc, &
                                                    local_rank,   &
                                                    total_ranks
      integer(i_def), intent(in)                 :: max_stencil_depth
      integer(i_def), intent(inout), allocatable :: global_cell_id(:)
      integer(i_def), intent(out)                :: num_inner(:), &
                                                    num_edge,     &
                                                    num_halo(:),  &
                                                    num_ghost
    end subroutine partitioner_interface
  end interface

contains

  !-------------------------------------------------------------------------------
  ! Constructs partition object
  !-------------------------------------------------------------------------------
  !> @brief Constructs a <code>partition_type</code> object
  !>
  !> @param [in] global_mesh A global mesh object that describes the layout
  !>                         of the global mesh
  !> @param [in] partitioner A function pointer to the function that will perform
  !>                         the partitioning
  !> @param [in] xproc Number of ranks to partition the mesh over in the
  !>                   x-direction (across a single face  for a cubed-sphere mesh)
  !> @param [in] yproc Number of ranks to partition the mesh over in the
  !>                   y-direction (across a single face  for a cubed-sphere mesh)
  !> @param [in] halo_depth The depth to which halos will be created
  !> @param [in] local_rank Number of the local process rank
  !> @param [in] total_ranks Total number of process ranks available
  !> @return self the partition object
  !-------------------------------------------------------------------------------
  function partition_constructor( global_mesh, &
                                  partitioner, &
                                  xproc, &
                                  yproc, &
                                  max_stencil_depth, &
                                  local_rank, &
                                  total_ranks) result(self)

  implicit none

  class(global_mesh_type),          pointer, intent(in) :: global_mesh
  procedure(partitioner_interface), pointer, intent(in) :: partitioner
  integer(i_def),                   intent(in) :: xproc
  integer(i_def),                   intent(in) :: yproc
  integer(i_def),                   intent(in) :: max_stencil_depth
  integer(i_def),                   intent(in) :: local_rank
  integer(i_def),                   intent(in) :: total_ranks

  type(partition_type), target :: self

  integer(i_def) :: cell
  integer(i_def) :: i
  integer(i_def) :: total_inners
  integer(i_def) :: last
  integer(i_def) :: halo_start, halo_finish

  integer(i_def), allocatable :: redist(:)

  self%local_rank = local_rank
  self%total_ranks = total_ranks
  self%halo_depth = max_stencil_depth + 1
  allocate( self%num_halo(self%halo_depth) )
  allocate( self%last_halo_cell(self%halo_depth) )
  self%inner_depth = max_stencil_depth + 1
  allocate( self%num_inner(self%inner_depth) )
  allocate( self%last_inner_cell(self%inner_depth) )
  self%global_num_cells = global_mesh%get_ncells()

  ! Call the partitioner that has been passed into the routine
  ! as a procedure pointer
  call partitioner( global_mesh, &
                    self%npanels, &
                    xproc, yproc, &
                    local_rank, &
                    total_ranks, &
                    max_stencil_depth, &
                    self%global_cell_id, &
                    self%num_inner, &
                    self%num_edge, &
                    self%num_halo, &
                    self%num_ghost )

  ! Derive the indices of the last cell in each category
  last=0
  do i=self%inner_depth, 1, -1
    last = last + self%num_inner(i)
    self%last_inner_cell(i)=last
  end do
  last = last + self%num_edge
  self%last_edge_cell=last
  do i=1,self%halo_depth
    last = last + self%num_halo(i)
    self%last_halo_cell(i)=last
  end do

  ! Calculate ownership of cells known to the local partition
  ! by filling the locally owned cells with the local rank and performing
  ! a halo-swap to fill in the owners of all the halo cells.
  !
  ! Set up the YAXT structures required to perform a halo swap
  !

  total_inners=0
  do i=1,self%inner_depth
    total_inners=total_inners+self%num_inner(i)
  end do

  allocate(self%cell_owner(self%get_num_cells_in_layer()+ &
                            self%get_num_cells_ghost()))

  halo_start  = total_inners+self%num_edge+1
  halo_finish = self%get_num_cells_in_layer()+self%get_num_cells_ghost()
  !If this is a serial run (no halos), halo_start is out of bounds - so fix it
  if(halo_start > self%get_num_cells_in_layer())then
    halo_start  = self%get_num_cells_in_layer()
    halo_finish = self%get_num_cells_in_layer() - 1
  end if

  !Get the redistribution map object for halo exchanging cell owners
  redist = generate_redistribution_map( &
     int(self%global_cell_id(1:total_inners+self%num_edge),kind=i_halo_index), &
     int(self%global_cell_id( halo_start:halo_finish ),kind=i_halo_index), &
     get_mpi_datatype( integer_type, i_def ) )

  ! Set ownership of all inner and edge cells to the local rank id
  ! - halo cells are unset
  do cell = 1,total_inners+self%num_edge
    self%cell_owner(cell)=local_rank
  end do

  end function partition_constructor

  !---------------------------------------------------------------------------
  !> @brief Constructs a small example partition for unit testing.
  !>
  !> @returns A partition object based on a 9-cell global mesh (3x3) with one
  !>          partition and quadralateral reference cells.
  !>
  function partition_constructor_unit_test_data() result (self)

    implicit none

    type(partition_type) :: self

    ! Returns partition object from global_mesh of size 3x3 quad reference cell
    ! (see global_mesh_mod for data) which only has one partition.

    self%local_rank        = 0
    self%total_ranks       = 1
    self%halo_depth        = 3
    self%inner_depth       = 1
    self%global_num_cells  = 9

    allocate( self%global_cell_id (self%global_num_cells) )
    allocate( self%cell_owner     (self%global_num_cells) )
    allocate( self%num_inner      (self%inner_depth) )
    allocate( self%last_inner_cell(self%inner_depth) )
    allocate( self%num_halo       (self%halo_depth) )
    allocate( self%last_halo_cell (self%halo_depth) )

    self%global_cell_id    = [1,2,3,4,5,6,7,8,9]
    self%cell_owner        = [0,0,0,0,0,0,0,0,0]
    self%num_inner(1)      = 9
    self%last_inner_cell(1)= 9
    self%num_edge          = 0
    self%last_edge_cell    = 9
    self%num_halo(1)       = 0
    self%num_halo(2)       = 0
    self%num_halo(3)       = 0
    self%last_halo_cell(1) = 9
    self%last_halo_cell(2) = 9
    self%last_halo_cell(3) = 9
    self%num_ghost         = 0

  end function partition_constructor_unit_test_data

  !---------------------------------------------------------------------------
  !> Deallocates all assigned memory.
  !>
  !> For use by unit tests only.
  !>
  !> @todo Is this even necessary? Doesn't the constructor fulfill this
  !>       function?
  !>
  subroutine clear(self)

    implicit none

    class (partition_type), intent(inout) :: self

    if ( allocated( self%cell_owner ) )      deallocate( self%cell_owner )
    if ( allocated( self%global_cell_id ) )  deallocate( self%global_cell_id )
    if ( allocated( self%num_halo ) )        deallocate( self%num_halo )
    if ( allocated( self%last_halo_cell ) )  deallocate( self%last_halo_cell )
    if ( allocated( self%num_inner ) )       deallocate( self%num_inner )
    if ( allocated( self%last_inner_cell ) ) deallocate( self%last_inner_cell )

  end subroutine clear

  !---------------------------------------------------------------------------
  !> Destructor.
  !>
  subroutine partition_destructor(self)

    implicit none
    type (partition_type), intent(inout) :: self

    call self%clear()

  end subroutine partition_destructor

  !---------------------------------------------------------------------------
  !> @brief Copy constructor.
  !>
  !> @param[out] dest Object to receive copy.
  !> @param[in] source Object to be copied.
  !>
  subroutine partition_type_assign(dest, source)

    implicit none

    class(partition_type), intent(out)   :: dest
    class(partition_type), intent(in)    :: source

    dest%local_rank = source%local_rank
    dest%total_ranks = source%total_ranks
    dest%halo_depth = source%halo_depth

    allocate( dest%num_halo(dest%halo_depth) )
    allocate( dest%last_halo_cell(dest%halo_depth) )
    dest%inner_depth = source%inner_depth
    allocate( dest%num_inner(dest%inner_depth) )
    allocate( dest%last_inner_cell(dest%inner_depth) )
    dest%global_num_cells = source%global_num_cells

    allocate( dest%global_cell_id( size(source%global_cell_id)) )
    dest%global_cell_id=source%global_cell_id
    dest%num_inner=source%num_inner
    dest%num_edge=source%num_edge
    dest%num_halo=source%num_halo
    dest%num_ghost=source%num_ghost

    dest%last_inner_cell=source%last_inner_cell
    dest%last_edge_cell=source%last_edge_cell
    dest%last_halo_cell=source%last_halo_cell

    dest%npanels=source%npanels
    allocate( dest%cell_owner(size(source%cell_owner)) )
    dest%cell_owner=source%cell_owner

  end subroutine partition_type_assign

  !---------------------------------------------------------------------------
  !> @brief Partitions the mesh on a plane. It returns the global
  !>        IDs of the cells in the given partition.
  !>
  !> @param[in] global_mesh  A global mesh object that describes the layout
  !>                         of the global mesh
  !> @param[out] num_panels  Number of panels in the 3D mesh.
  !> @param[in] xproc  Number of processors along x-direction.
  !> @param[in] yproc  Number of processors along y-direction.
  !> @param[in] local_rank  Local MPI rank number.
  !> @param[in] total_ranks  Total number of MPI ranks.
  !> @param[in] max_stencil_depth  The maximum depth of stencil that will be
  !>                               used with this partition.
  !> @param[inout] partitioned_cells  Returned array that holds the global IDs
  !>                                  of all cells in local partition.
  !> @param[out] num_inner  Number of cells that are inner halo cells.
  !> @param[out] num_edge  Number of cells that are owned by the partition,
  !>                       but may have dofs that are also owned by halo cells.
  !> @param[out] num_halo  Number of cells that are halo cells.
  !> @param[out] num_ghost  Number of "ghost" cells. These are cells in an
  !>                        extra halo around the outermost actual halo and
  !>                        are not in the partitioned domain, but are
  !>                        required to fully describe the cells in the
  !>                        partitioned domain.
  !>
  subroutine partitioner_planar( global_mesh,       &
                                 num_panels,        &
                                 xproc,             &
                                 yproc,             &
                                 local_rank,        &
                                 total_ranks,       &
                                 max_stencil_depth, &
                                 partitioned_cells, &
                                 num_inner,         &
                                 num_edge,          &
                                 num_halo,          &
                                 num_ghost )
    implicit none

    class(global_mesh_type), pointer, intent(in) :: global_mesh

    integer(i_def),              intent(out)   :: num_panels
    integer(i_def),              intent(in)    :: xproc
    integer(i_def),              intent(in)    :: yproc
    integer(i_def),              intent(in)    :: local_rank
    integer(i_def),              intent(in)    :: total_ranks
    integer(i_def),              intent(in)    :: max_stencil_depth
    integer(i_def), allocatable, intent(inout) :: partitioned_cells( : )
    integer(i_def),              intent(out)   :: num_inner( : )
    integer(i_def),              intent(out)   :: num_edge
    integer(i_def),              intent(out)   :: num_halo( : )
    integer(i_def),              intent(out)   :: num_ghost

    ! A biperiodic mesh has 1 panel
    num_panels = 1

    call partitioner_rectangular_panels( global_mesh, &
                                        num_panels, &
                                        xproc, &
                                        yproc, &
                                        local_rank, &
                                        total_ranks, &
                                        max_stencil_depth, &
                                        partitioned_cells, &
                                        num_inner, &
                                        num_edge, &
                                        num_halo, &
                                        num_ghost )

  end subroutine partitioner_planar


  !---------------------------------------------------------------------------
  !> @brief Partitions the mesh on cubed_sphere. It returns the global IDs of
  !>        the cells in the given partition.
  !>
  !> @param[in]  global_mesh  A global mesh object that describes the layout
  !>                          of the global mesh
  !> @param[out] num_panels  Number of panels in the 3D mesh.
  !> @param[in]  xproc  Number of processors along x-direction.
  !> @param[in]  yproc  Number of processors along y-direction.
  !> @param[in]  local_rank  Local MPI rank number.
  !> @param[in]  total_ranks  Total number of MPI ranks.
  !> @param[in] max_stencil_depth  Maximum depth of stencil that will be used
  !>                               with this partition.
  !> @param[inout] partitioned_cells  Holds the global IDs of all cells in
  !>                                  local partition.
  !> @param[out] num_inner  Number of cells that are inner halo cells.
  !> @param[out] num_edge  Number of cells that are owned by the partition,
  !>                       but may have dofs that are also owned by halo
  !>                       cells.
  !> @param[out] num_halo  Number of cells that are halo cells.
  !> @param[out] num_ghost  Number of "ghost" cells. These are cells in an
  !>                        extra halo around the outermost actaul halo and
  !>                        are not in the partitioned domain, but are
  !>                        required to fully describe the cells in the
  !>                        partitioned domain.
  !>
  subroutine partitioner_cubedsphere( global_mesh,       &
                                      num_panels,        &
                                      xproc,             &
                                      yproc,             &
                                      local_rank,        &
                                      total_ranks,       &
                                      max_stencil_depth, &
                                      partitioned_cells, &
                                      num_inner,         &
                                      num_edge,          &
                                      num_halo,          &
                                      num_ghost )
    implicit none

    class(global_mesh_type), pointer, intent(in) :: global_mesh

    integer(i_def),              intent(out)   :: num_panels
    integer(i_def),              intent(in)    :: xproc
    integer(i_def),              intent(in)    :: yproc
    integer(i_def),              intent(in)    :: local_rank
    integer(i_def),              intent(in)    :: total_ranks
    integer(i_def),              intent(in)    :: max_stencil_depth
    integer(i_def), allocatable, intent(inout) :: partitioned_cells( : )
    integer(i_def),              intent(out)   :: num_inner( : )
    integer(i_def),              intent(out)   :: num_edge
    integer(i_def),              intent(out)   :: num_halo( : )
    integer(i_def),              intent(out)   :: num_ghost

    ! A cubed sphere has 6 panels
    num_panels = 6

    !check that we have a number of ranks that is compatible with this partitioner
    if( modulo(total_ranks,num_panels) /= 0 ) call log_event( &
    'The cubed-sphere partitioner requires a multiple of six processors.', &
    LOG_LEVEL_ERROR )

    call partitioner_rectangular_panels( global_mesh, &
                                        num_panels, &
                                        xproc, &
                                        yproc, &
                                        local_rank, &
                                        total_ranks, &
                                        max_stencil_depth, &
                                        partitioned_cells, &
                                        num_inner, &
                                        num_edge, &
                                        num_halo, &
                                        num_ghost )

  end subroutine partitioner_cubedsphere

  !---------------------------------------------------------------------------
  !> @brief Partitions a cubed-sphere mesh into a single partition for use
  !>        when running the code serialially.
  !>
  !> @param[in]  global_mesh  Global mesh objectto be partitioned.
  !> @param[in]  xproc  Number of processors along x-direction.
  !> @param[in]  yproc  Number of processors along y-direction.
  !> @param[in]  local_rank  Local MPI rank number.
  !> @param[in]  total_ranks  Total number of MPI ranks.
  !> @param[in]  max_stencil_depth  Maximum depth of stencil that will be used
  !>                                with this partition.
  !> @param[inout] partitioned_cells  Holds the global IDs of all cells in
  !>                                  local partition.
  !> @param[out] num_inner  Number of cells that are inner halo cells.
  !> @param[out] num_edge  Number of cells that are owned by the partition,
  !>                       but may have dofs that are also owned by halo cells.
  !> @param[out] num_halo  Number of cells that are halo cells.
  !> @param[out] num_ghost  Number of "ghost" cells. These are cells in an
  !>                        extra halo around the outermost actaul halo and
  !>                        are not in the partitioned domain, but are
  !>                        required to fully describe the cells in the
  !>                        partitioned domain
  !>
  subroutine partitioner_cubedsphere_serial( global_mesh,       &
                                             num_panels,        &
                                             xproc,             &
                                             yproc,             &
                                             local_rank,        &
                                             total_ranks,       &
                                             max_stencil_depth, &
                                             partitioned_cells, &
                                             num_inner,         &
                                             num_edge,          &
                                             num_halo,          &
                                             num_ghost )

    use log_mod, only : log_event, LOG_LEVEL_ERROR

  ! The general partitioner for a cubed-sphere mesh returns a minimum of one
  ! partition per cubed-sphere "face". In order to run the code serially
  ! a special case for creating a single partition with all points is required.
  ! So here. we just return one big partition that holds everything
    implicit none

    class(global_mesh_type), pointer, intent(in) :: global_mesh

    integer(i_def),              intent(out)   :: num_panels
    integer(i_def),              intent(in)    :: xproc
    integer(i_def),              intent(in)    :: yproc
    integer(i_def),              intent(in)    :: local_rank
    integer(i_def),              intent(in)    :: total_ranks
    integer(i_def),              intent(in)    :: max_stencil_depth
    integer(i_def), allocatable, intent(inout) :: partitioned_cells( : )
    integer(i_def),              intent(out)   :: num_inner( : )
    integer(i_def),              intent(out)   :: num_edge
    integer(i_def),              intent(out)   :: num_halo( : )
    integer(i_def),              intent(out)   :: num_ghost

    integer(i_def) :: i

    ! A cubed sphere has 6 panels
    num_panels = 6

    if( total_ranks /= 1 .or. local_rank /= 0 )then
    call log_event( 'Can only use the serial partitioner with a single process',&
      LOG_LEVEL_ERROR )
    endif

    if( xproc /= 1 .or. yproc /= 1)then
    call log_event( 'Invalid decomposition used for serial partitioner',&
      LOG_LEVEL_ERROR )
    endif

    num_inner(:) = 0
    num_inner(size(num_inner)) =  global_mesh%get_ncells()
    num_edge = 0
    num_halo(:) = 0
    num_ghost=0

    allocate(partitioned_cells(num_inner(size(num_inner))))
    do i = 1,num_inner(size(num_inner))
      partitioned_cells(i)= i
    end do

  end subroutine partitioner_cubedsphere_serial

  !-------------------------------------------------------------------------------
  ! Helper routine that partitions a mesh that is formed from a number
  ! of rectangular panels.
  !-------------------------------------------------------------------------------
  subroutine partitioner_rectangular_panels( global_mesh, &
                                             num_panels, &
                                             xproc, &
                                             yproc, &
                                             local_rank, &
                                             total_ranks, &
                                             max_stencil_depth, &
                                             partitioned_cells, &
                                             num_inner, &
                                             num_edge, &
                                             num_halo, &
                                             num_ghost )

    use linked_list_int_mod,   only : linked_list_int_type
    use linked_list_mod,       only : linked_list_type, &
                                      linked_list_item_type, &
                                      before
    use reference_element_mod, only : W, S, E, N

    implicit none

    class(global_mesh_type), pointer, &
                                 intent(in)    :: global_mesh             ! A global mesh object

    integer(i_def),              intent(in)    :: num_panels              ! Number of panels that make up the mesh
    integer(i_def),              intent(in)    :: xproc                   ! Number of processors along x-direction
    integer(i_def),              intent(in)    :: yproc                   ! Number of processors along y-direction
    integer(i_def),              intent(in)    :: local_rank              ! Local MPI rank number
    integer(i_def),              intent(in)    :: total_ranks             ! Total number of MPI ranks
    integer(i_def),              intent(in)    :: max_stencil_depth       ! The maximum depth of stencil that will be used
                                                                          ! with this partition
    integer(i_def), allocatable, intent(inout) :: partitioned_cells( : )  ! Returned array that holds the global ids of
                                                                          ! all cells in local partition
    integer(i_def),              intent(out)   :: num_inner( : )          ! Number of cells that are inner halo cells.
    integer(i_def),              intent(out)   :: num_edge                ! Number of cells that are owned by the partition,
                                                                          ! but may have dofs that are also owned by halo cells.
    integer(i_def),              intent(out)   :: num_halo( : )           ! Number of cells that are halo cells.
    integer(i_def),              intent(out)   :: num_ghost               ! Number of cells that are ghost cells - surrounding,
                                                                          ! but not in the partitioned domain

    integer(i_def) :: face      ! which face of the cube is implied by local_rank (0->5)
    integer(i_def) :: start_cell ! lowest cell id of the face implaced by local_rank
    integer(i_def) :: start_rank ! The number of the first rank on the face implied by local_rank
    integer(i_def) :: local_xproc, local_yproc ! x- and y-dirn processor id of this partition
    integer(i_def) :: start_x   ! global cell id of start of the domain on this partition in x-dirn
    integer(i_def) :: num_x     ! number of cells in the domain on this partition in x-dirn
    integer(i_def) :: start_y   ! global cell id of start of the domain on this partition in y-dirn
    integer(i_def) :: num_y     ! number of cells in the domain on this partition in y-dirn
    integer(i_def) :: ix, iy    ! loop counters over cells on this partition in x- and y-dirns

    ! Create linked lists

    type(linked_list_type)         :: partition   ! a list of all cells in the partition
    type(linked_list_type), target :: known_cells ! a list of cells known to this partition

    type(linked_list_item_type), pointer :: last=>null() ! location of the last added cell in the list of cells
    type(linked_list_item_type), pointer :: start_subsect=>null() ! start position when looping over subsections of cells
    type(linked_list_item_type), pointer :: insert_point=>null() ! where to insert in a list
    type(linked_list_item_type), pointer :: loop => null() ! temp ptr to loop through list



    integer :: i, j         ! loop counters
    integer :: cells(4)     ! The cells around the vertex being queried
    integer :: oth1, oth2   ! When querying a cell around a vertex, these are
                            ! the indices of the other two cells
    integer, allocatable :: sw_corner_cells(:)
                            ! List of cells at the SW corner of the panels
    integer :: panel        ! panel number
    integer :: cell         ! starting point for num_cells_x calculation
    integer :: cell_n       ! temporary variable to store next cell
    integer :: cell_next(4) ! The cells around the cell being queried
    integer :: num_cells_x  ! number of cells across a panel in x-direction
    integer :: num_cells_y  ! number of cells across a panel in y-direction
    integer :: start_sort, end_sort ! range over which to sort cells
    integer :: depth        ! counter over the halo depths
    integer :: orig_num_in_list ! number of cells in list before halos are added
    integer(i_def) :: num_apply
    logical(l_def) :: periodic_x = .false. ! Periodic in the E-W direction
    logical(l_def) :: periodic_y = .false. ! Periodic in the N-S direction

    call global_mesh%get_mesh_periodicity(periodic_x, periodic_y)

    if(num_panels==1)then
      ! A single panelled mesh might be rectangluar - so find the dimensions
      ! First determine the southwest corner cell depending on periodicity. If
      ! biperiodic, cell ID 1 can be used as mesh conectivity loops round
      cell = 1
      call global_mesh%get_cell_next(cell,cell_next)
      if (.not. periodic_x) then
        ! If not periodic in E-W direction then walk West until you reach mesh
        ! edge defined by cell ID -1 (this is set by the mesh generator)
        do while (cell_next(W) /= -1)
          cell = cell_next(W)
          call global_mesh%get_cell_next(cell,cell_next)
        end do
      end if

      if (.not. periodic_y) then
        ! If not periodic in N-S direction then walk South until you reach mesh
        ! edge defined by cell ID -1 (this is set by the mesh generator)
        do while (cell_next(S) /= -1)
          cell = cell_next(S)
          call global_mesh%get_cell_next(cell,cell_next)
        end do
      end if

      ! Assign cell ID of SW corner of mesh
      allocate(sw_corner_cells(1))
      sw_corner_cells(1) = cell

      ! Work out number of cells in x and y directions
      num_cells_x = 1

      ! Starting in the SW corner of the mesh so must walk East on non-periodic
      ! meshes to determine number of cells in the x direction
      do while (cell_next(E) /= cell .and. cell_next(E) /= -1)
        num_cells_x=num_cells_x+1
        cell_n = cell_next(E)
        call global_mesh%get_cell_next(cell_n, cell_next)
      end do

      ! Infer num_cells_y from the total domin size and num_cells_x
      num_cells_y=global_mesh%get_ncells()/num_cells_x

    else
      ! For multi-panel meshes, the panels must be square
      num_cells_x = nint(sqrt( real(global_mesh%get_ncells(), kind=r_def)/ &
                               real(num_panels, kind=r_def) ))
      num_cells_y = num_cells_x

      ! Calculate the South West corner cells of all the panels in the global mesh
      allocate(sw_corner_cells(num_panels))
      panel=1
      do i=1,global_mesh%get_nverts()
        call global_mesh%get_cell_on_vert(i,cells)
        if(cells(4) == 0)then
          do j=1,3
            call global_mesh%get_cell_next(cells(j),cell_next)
            oth1=j+1
            if(oth1>3)oth1=oth1-3
            oth2=j+2
            if(oth2>3)oth2=oth2-3
            if(cell_next(N)/=cells(oth1) .and. cell_next(N)/=cells(oth2) .and. &
              cell_next(E)/=cells(oth1) .and. cell_next(E)/=cells(oth2) ) then
              if(panel > num_panels) &
                call log_event( 'Failed to partition the mesh: '// &
                  'the global mesh has more panels than the partitioner '// &
                  'is expecting.', LOG_LEVEL_ERROR )
              sw_corner_cells(panel)=cells(j)
              panel=panel+1
            end if
          end do
        end if
      end do

    endif

    !convert the local rank number into a face number and a local xproc and yproc
    face = ((num_panels*local_rank)/total_ranks) + 1
    start_cell = sw_corner_cells(face)
    start_rank = xproc*yproc*(face-1)
    local_xproc = modulo(local_rank-start_rank,xproc)
    local_yproc = (local_rank-start_rank)/xproc

    deallocate(sw_corner_cells)

    !Work out the start index and number of cells (in x- and y-dirn) for
    !the local partition - this algorithm should spread out the number of
    !cells each partition gets fairly evenly
    start_x = ( (local_xproc*num_cells_x) / xproc ) + 1
    num_x   = ( ((local_xproc+1)*num_cells_x) / xproc ) - start_x + 1
    start_y = ( (local_yproc*num_cells_y) / yproc ) + 1
    num_y   = ( ((local_yproc+1)*num_cells_y) / yproc ) - start_y + 1

    !Create a linked list of all cells that are part of this partition (not halos)

    partition = linked_list_type()

    do iy = start_y, start_y+num_y - 1
      do ix = start_x, start_x+num_x - 1
        call partition%insert_item( linked_list_int_type( &
                                global_mesh%get_cell_id(start_cell, ix-1, iy-1)))
      end do
    end do

    ! Create a linked-list of all cells known to the partition, including halos.
    ! This will be ordered as:
    ! inner n, inner n-1 ... inner 1, edge, halo 1 ... halo n-1, halo n
    !
    ! Start with the edge cells - those cells owned by the partition - but are on
    ! the edge of the partitioned domain, so may have dofs shared with halo cells

    known_cells = linked_list_type()

    ! Those cells along the top/bottom

    do ix = start_x, start_x+num_x-1
      ! start inserting the edge cells
      call known_cells%insert_item(linked_list_int_type( &
                          global_mesh%get_cell_id(start_cell, ix-1, start_y-1)))
      ! insert but check for duplicates between start and end of known_cells list
      if(.not. (known_cells%item_exists(global_mesh%get_cell_id( &
                                    start_cell, ix-1, start_y+num_y-2)) ) ) then
        call known_cells%insert_item( linked_list_int_type( &
                    global_mesh%get_cell_id(start_cell, ix-1, start_y+num_y-2)))
      end if
    end do
    ! Those along the left/right
    do iy = start_y+1, start_y+num_y-2
      if(.not. (known_cells%item_exists(global_mesh%get_cell_id( &
                                        start_cell, start_x-1, iy-1)) )) then
        call known_cells%insert_item( linked_list_int_type( &
                          global_mesh%get_cell_id(start_cell, start_x-1, iy-1)))
      end if
      if(.not. (known_cells%item_exists(global_mesh%get_cell_id( &
                                      start_cell, start_x+num_x-2, iy-1)) )) then
        call known_cells%insert_item( linked_list_int_type( &
                    global_mesh%get_cell_id(start_cell, start_x+num_x-2, iy-1)))
      end if
    end do

    ! get the number of edge cells currently stored in the known_cells list
    num_edge = known_cells%get_length()

    ! Add all cells from the halos (up to max_stencil_depth+1) that are in a
    ! stencil around each of the owned cells, but are not part of the partition.
    ! Also add a "ghost" halo (max_stencil_depth+2) - used later to work out
    ! dof ownerships
    start_subsect => known_cells%get_head() ! start at the beginning
                                            ! of known_cells list
    ! num cells to apply stencil to is the number of edge cells
    num_apply=num_edge
    ! get a pointer to the known_cells list
    !known_cells_ptr => known_cells
    ! insert point is end of current list
    insert_point => known_cells%get_tail()
    do depth = 1,max_stencil_depth +2
      ! update number of cells currently in known_cells
      orig_num_in_list = known_cells%get_length()
      last => known_cells%get_tail() ! point at tail of current known_cells list
      call apply_stencil( global_mesh, &
                          known_cells, & ! the current list of known cells
                          start_subsect, & ! where we want to start applying stencil in known_cells
                          num_apply, & ! the number of items in known_cells to iterate over
                          insert_point=insert_point, & ! where to insert in list
                          exclude=partition ) ! exclude cells in partition
      if(depth <= max_stencil_depth+1)then
        num_halo(depth) = known_cells%get_length() - orig_num_in_list ! num halo cells at this depth
                                                                      ! is the number we just added
        ! if cells were added at this depth, reset start point to previous end of known_cells list
        if (num_halo(depth) > 0) then
          start_subsect => last%next
        end if
        ! reset insert point to current end of list
        insert_point => known_cells%get_tail()
        ! num cells to apply stencil to next is the number of cells just added to known_cells
        num_apply = num_halo(depth)
      else
        ! num ghost cells is the number we just added to known_cells at max_stencil_depth + 2
        num_ghost = known_cells%get_length() - orig_num_in_list
      end if
    end do


    ! Add all cells from the inner halos (up to max_stencil_depth) that are in a
    ! stencil around each of the owned cells, but are not part of the outer halos

    ! Point to start of known_cells list
    start_subsect => known_cells%get_head()
    ! insert point is head of known cells list as we want to insert before it
    insert_point => known_cells%get_head()
    ! num cells to apply stencil to is the number of edge cells only (not halo cells)
    num_apply=num_edge
    do depth = 1,max_stencil_depth
      ! update number of cells currently in known_cells
      orig_num_in_list = known_cells%get_length()
      call apply_stencil( global_mesh, &
                          known_cells, &
                          start_subsect, &
                          num_apply, &
                          insert_point=insert_point, & ! where to insert in list
                          placement=before )
      ! num inner halo cells at this depth is the number we just added to known_cells
      num_inner(depth) = known_cells%get_length()  - orig_num_in_list
      ! num cells to apply stencil to next is the number of cells just added to known_cells
      num_apply = num_inner(depth)
      ! reset start point to current head of known_cells list
      start_subsect => known_cells%get_head()
      ! and reset insert point also
      insert_point => known_cells%get_head()
    end do

    ! Now check partition list for any cells not yet added. These must be inner halo
    ! cells of depth max_stencil_depth+1

    num_inner(max_stencil_depth+1)=0
    ! update number of cells currently in known_cells
    orig_num_in_list = known_cells%get_length()
    ! point at head of partition list
    loop => partition%get_head()
    ! update insert point to head of known_cells list
    insert_point => known_cells%get_head()
    if (partition%get_length() > 0) then

      do i = 1,partition%get_length()

        if(.not. (known_cells%item_exists(loop%payload%get_id()))) then

          call known_cells%insert_item( linked_list_int_type(loop%payload%get_id()), &
                                        insert_point=insert_point, placement=before)
        end if
        ! update insert point to head of known_cells list
        insert_point => known_cells%get_head()
        loop => loop%next
      end do
      ! update num_inner cells added
      num_inner(max_stencil_depth+1)=known_cells%get_length()  - orig_num_in_list
    end if

    allocate(partitioned_cells(known_cells%get_length()))
    ! reset loop to start of known_cells
    loop => known_cells%get_head()



    ! Copy cell ids from known_cells list to partitioned_cells array
    do i = 1,known_cells%get_length()
      partitioned_cells(i) = loop%payload%get_id()
      if ( .not. associated(loop%next) ) exit !finished
      loop => loop%next
    end do


    ! Deallocate the known_cells list
    call known_cells%clear()

    ! Cell ids within the separate groups have to be in numerical order.
    ! so (bubble) sort the separate groups
    !
    ! Sort the individual depths of inner halo cells
    end_sort=0
    do depth = max_stencil_depth+1, 1, -1
      start_sort = end_sort + 1
      end_sort = start_sort + num_inner(depth) - 1
      call bubble_sort( partitioned_cells(start_sort:end_sort), &
                        end_sort-start_sort+1 )
    end do
    !
    ! Sort edge cells
    start_sort = end_sort + 1
    end_sort = start_sort + num_edge - 1
    call bubble_sort( partitioned_cells(start_sort:end_sort), &
                      end_sort-start_sort+1 )
    !
    ! Sort the individual depths of halo cells
    do depth = 1,max_stencil_depth+1
      start_sort = end_sort + 1
      end_sort = start_sort + num_halo(depth) - 1
      call bubble_sort( partitioned_cells(start_sort:end_sort), &
                        end_sort-start_sort+1 )
    end do
    !
    ! Sort the ghost halo
    start_sort = end_sort + 1
    end_sort = start_sort + num_ghost - 1
    call bubble_sort( partitioned_cells(start_sort:end_sort), &
                      end_sort-start_sort+1 )

    nullify( last, start_subsect, insert_point, loop )

  end subroutine partitioner_rectangular_panels

  !---------------------------------------------------------------------------
  ! Applies a stencil around a collection of cells.
  !
  ! Details: Applies a single depth stencil around a collection of cells and
  !          adds the global ids of the stencil cells to a list of cells known
  !          to the partition - if they are not already in the list.
  ! Input:   global_mesh      A global mesh object that describes the layout
  !                           of the global mesh.
  !          input_cells      A pointer to the start of a portion of the
  !                           linked list over which the stencil will be
  !                           applied.
  !          number_of_cells  The number of cells in the portion of the linked
  !                           list over which the stencil will be applied.
  ! In/Out:  known_cells      The current linked list known_cells.
  !
  ! Optional: insert_point    Where to insert before/after in known_cells.
  !
  !           placement       Flag to insert before or after insert point.
  !
  !           exclude         An additional list to check for duplicates.
  !
  subroutine apply_stencil( global_mesh, &
                            known_cells, &
                            input_cells, &
                            number_of_cells, &
                            insert_point, &
                            placement, &
                            exclude )
    use linked_list_int_mod, only : linked_list_int_type
    use linked_list_mod,     only : linked_list_type, &
                                    linked_list_item_type, &
                                    before

    implicit none

    class(global_mesh_type),              pointer,  intent(in)    :: global_mesh
    type(linked_list_type),                         intent(inout) :: known_cells
    type(linked_list_item_type),target,             intent(inout) :: input_cells
    integer(i_def),                                 intent(in)    :: number_of_cells
    type(linked_list_item_type), optional,target,   intent(inout) :: insert_point
    integer(i_def),         optional,               intent(in)    :: placement
    type(linked_list_type), optional,               intent(in)    :: exclude

    integer(i_def) :: i,j,k  ! loop counter
    integer(i_def) :: cell_id ! the current cell id that the stencil is being applied to
    integer(i_def) :: add_cell ! flag controlling whether to insert after checking duplicates
    integer(i_def), allocatable :: verts(:)
    integer(i_def), allocatable :: cells(:)

    type(linked_list_item_type), pointer :: loop => null() ! temp ptr to loop through list
    type(linked_list_item_type), pointer :: insert_ptr => null() ! pointer to access insert_point

    allocate( cells( global_mesh%get_max_cells_per_vertex() ) )
    allocate( verts(global_mesh%get_nverts_per_cell()) )


    ! point at where we want to start
    loop => input_cells
    insert_ptr => insert_point

    ! iterate through the list for the given number of cells
    do i = 1,number_of_cells
      ! get cell id for current item
      cell_id = loop%payload%get_id()
      ! get list of vertices on this cell
      call global_mesh%get_vert_on_cell(cell_id, verts)
      ! iterate through these verts
      do j = 1, global_mesh%get_nverts_per_cell()
        ! get all the cells sharing this vert
        call global_mesh%get_cell_on_vert( verts(j), cells )
        ! iterate through these cells
        do k = 1,global_mesh%get_max_cells_per_vertex()
          ! Assume we are not adding the cell at first
          ! then flag for adding depending on checks
          add_cell = 0
          if(cells(k) > 0)then
            ! check if cell is already in known_cells list
            if (.not.(known_cells%item_exists(cells(k)))) then
              ! Not in known_cells so flag to add initially
              add_cell = 1
              ! .... but also check exclude list if it is present
              if (present(exclude)) then
                if (exclude%item_exists(cells(k))) then
                  ! It is in the exclude list so don't flag
                  add_cell = 0
                end if
              end if

            end if

            if (add_cell == 1) then
              ! add this cell
              call known_cells%insert_item( linked_list_int_type(cells(k)), &
                                            insert_point=insert_ptr, &
                                            placement=placement)

              ! If we added then need to update insert point according to placement
              if (present(insert_point)) then
                if (present(placement)) then
                  if (placement == before) then
                    insert_ptr => insert_ptr%prev
                  else
                    insert_ptr => insert_ptr%next
                  end if
                else
                  ! No placement present so default is to insert after
                  insert_ptr => insert_ptr%next
                end if
              end if
            end if

          end if
        end do
      end do
      ! point at next item
      loop=>loop%next
    end do

    if (allocated(verts)) deallocate(verts)
    if (allocated(cells)) deallocate(cells)

    nullify(loop, insert_ptr)

  end subroutine apply_stencil

  !---------------------------------------------------------------------------
  !> @brief Gets the total of all inner, edge and all halo cells in a 2d slice
  !>        on the local partition.
  !>
  !> @return The total number of the all inner, edge and halo cells on the
  !>         local partition.
  !>
  function get_num_cells_in_layer( self ) result ( num_cells )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: num_cells
    integer(i_def) :: depth   ! loop counter over halo depths

    num_cells = self%num_edge

    do depth = 1,self%inner_depth
      num_cells = num_cells + self%num_inner(depth)
    end do

    do depth = 1,self%halo_depth
      num_cells = num_cells + self%num_halo(depth)
    end do

  end function get_num_cells_in_layer

  !---------------------------------------------------------------------------
  !> @brief Gets the maximum depth of the inner halos.
  !>
  !> @return The maximum depth of the inner halos.
  !>
  function get_inner_depth( self ) result ( inner_depth )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: inner_depth

    inner_depth = self%inner_depth

  end function get_inner_depth

  !---------------------------------------------------------------------------
  !> @brief Gets number of cells in an inner halo.
  !>
  !> @details Returns the total number of inner halo cells in a particular
  !>          depth of inner halo in a 2d slice on the local partition.
  !>
  !> @param[in] depth Number of shells into halo.
  !>
  !> @return Total number of inner halo cells on the local partition. If depth
  !>         is greater than the actual depth of the halo then 0 will be
  !>         returned.
  !>
  function get_num_cells_inner( self, depth ) result ( inner_cells )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: depth
    integer(i_def)             :: inner_cells

    if( depth > self%inner_depth )then
      inner_cells = 0
    else
      inner_cells = self%num_inner(depth)
    end if

  end function get_num_cells_inner

  !---------------------------------------------------------------------------
  !> @brief Gets the index of the last cell in an inner halo.
  !>
  !> @details Returns the index of the last cell in a particular depth of
  !>          inner halo in a 2d slice on the local partition.
  !>
  !> @param[in] depth Number of shells to descend into halo.
  !>
  !> @return Index of the last cell in the particular depth of inner halo on
  !>         the local partition.
  !>
  function get_last_inner_cell( self, depth ) result ( last_inner_cell )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: depth
    integer(i_def)             :: last_inner_cell

    if( depth > self%inner_depth )then
      last_inner_cell = 0
    else
      last_inner_cell = self%last_inner_cell(depth)
    end if

  end function get_last_inner_cell

  !---------------------------------------------------------------------------
  !> @brief Gets the total number of edge cells in a 2d slice on the local
  !>        partition.
  !>
  !> @return Total number of "edge" cells on the local partition.
  !>
  function get_num_cells_edge( self ) result ( edge_cells )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: edge_cells

    edge_cells = self%num_edge

  end function get_num_cells_edge

  !---------------------------------------------------------------------------
  !> @brief Gets the index of the last edge cell in a 2d slice on the local
  !>        partition.
  !>
  !> @return Index of the last of "edge" cell on the local partition.
  !>
  function get_last_edge_cell( self ) result ( last_edge_cell )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: last_edge_cell

    last_edge_cell = self%last_edge_cell

  end function get_last_edge_cell

  !---------------------------------------------------------------------------
  !> @brief Gets the maximum depth of the halo of this partition.
  !>
  !> @return Maximum depth of halo cells.
  !>
  function get_halo_depth( self ) result ( halo_depth )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: halo_depth

    halo_depth = self%halo_depth

  end function get_halo_depth


  !---------------------------------------------------------------------------
  !> @brief Gets number of cells in a halo.
  !>
  !> @details Returns the total number of halo cells in a particular depth
  !>          of halo in a 2d slice on the local partition.
  !>
  !> @param[in] depth The depth of the halo being queried.
  !>
  !> @return Total number of halo cells of the particular depth on the local
  !>         partition.
  !>
  function get_num_cells_halo( self, depth ) result ( halo_cells )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: depth
    integer(i_def)             :: halo_cells

    if( depth > self%halo_depth )then
      halo_cells = 0
    else
      halo_cells = self%num_halo(depth)
    end if

  end function get_num_cells_halo

  !---------------------------------------------------------------------------
  !> @brief Gets the index of the last cell in a halo.
  !>
  !> @details Returns the index of the last cell in a particular depth of halo
  !>          in a 2d slice on the local partition.
  !>
  !> @param[in] depth The depth of the halo being queried.
  !>
  !> @return Index of the last cell in the particular depth of halo on the
  !>         local partition.
  !>
  function get_last_halo_cell( self, depth ) result ( last_halo_cell )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: depth
    integer(i_def)             :: last_halo_cell

    if( depth > self%halo_depth )then
      last_halo_cell = 0
    else
      last_halo_cell = self%last_halo_cell(depth)
    end if

  end function get_last_halo_cell

  !---------------------------------------------------------------------------
  !> @brief Gets the total number of ghost cells in a slice around the local
  !>        partition.
  !>
  !> @return Total number of ghost cells around the local partition.
  !>
  function get_num_cells_ghost( self ) result ( ghost_cells )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: ghost_cells

    ghost_cells = self%num_ghost

  end function get_num_cells_ghost

  !---------------------------------------------------------------------------
  !> @brief Gets the number of panels in the global mesh.
  !>
  !> @return Number of panels.
  !>
  function get_num_panels_global_mesh ( self ) result ( number_of_panels )

    implicit none

    class(partition_type), intent(in) :: self
    integer(i_def) :: number_of_panels

    number_of_panels = self%npanels

  end function get_num_panels_global_mesh

  !---------------------------------------------------------------------------
  !> @brief Gets the local rank number.
  !>
  !> @return Number of the local MPI rank.
  !>
  function get_local_rank( self ) result ( local_rank )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: local_rank

    local_rank = self%local_rank

  end function get_local_rank


  !---------------------------------------------------------------------------
  !> @brief Gets the total number of ranks.
  !>
  !> @return Total number of MPI ranks.
  !>
  function get_total_ranks( self ) result ( total_ranks )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def) :: total_ranks

    total_ranks = self%total_ranks

  end function get_total_ranks

  !---------------------------------------------------------------------------
  !> @brief Gets the owner of a cell on the local partition.
  !>
  !> @param[in] cell_number Local ID of of the cell being queried.
  !>
  !> @return Owner of the given cell.
  !>
  function get_cell_owner( self, cell_number ) result ( cell_owner )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: cell_number

    integer(i_def) :: cell_owner

    cell_owner=self%cell_owner(cell_number)

  end function get_cell_owner

  !---------------------------------------------------------------------------
  !> @brief Gets the global index of the cell that corresponds to the given
  !>        local index on the local partition.
  !>
  !> @param[in] lid ID of a cell in local index space.
  !>
  !> @return ID of a cell in global index space.
  !>
  function get_gid_from_lid( self, lid ) result ( gid )

    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: lid           ! local index
    integer(i_def)             :: gid           ! global index
    integer(i_def)             :: nlayer        ! layer of supplied lid
    integer(i_def)             :: lid_in_layer  ! supplied lid projected to bottom layer
    integer(i_def)             :: num_in_list   ! total number of cells in partition
    integer(i_def)             :: depth         ! loop counter over halo depths
    num_in_list = self%num_edge + self%num_ghost
    do depth = 1,self%inner_depth
      num_in_list = num_in_list + self%num_inner(depth)
    end do
    do depth = 1,self%halo_depth
      num_in_list = num_in_list + self%num_halo(depth)
    end do
    lid_in_layer = modulo(lid-1,(num_in_list))+1
    nlayer = (lid-1)/(num_in_list)

    gid = self%global_cell_id(lid_in_layer) + nlayer*(self%global_num_cells)
  end function get_gid_from_lid

  !---------------------------------------------------------------------------
  !> @brief Gets the local index of the cell on the local partition that
  !>        corresponds to the given global index.
  !>
  !> @param[in] gid Global index to search for on the local partition.
  !>
  !> @return Local index that corresponds to the given global index or -1 if
  !>         the cell with the given global index is not present of the local
  !>         partition
  !>
  function get_lid_from_gid( self, gid ) result ( lid )
  !
  ! Performs a search through the global cell lookup table looking for the
  ! required global index.
  !
  ! The partitioned_cells array holds global indices in various groups:
  ! the inner halos, then the edge cells, the halo cells and finally
  ! the ghost cells. The cells are numerically ordered within the different
  ! groups so a binary search can be used, but not between groups, so need to do
  ! separate binary searches through the inner, edge, halo and ghost cells and
  ! exit if a match is found
  !
    implicit none

    class(partition_type), intent(in) :: self

    integer(i_def), intent(in) :: gid           ! global index
    integer(i_def)             :: lid           ! local index
    integer(i_def)             :: nlayer        ! layer of supplied gid
    integer(i_def)             :: gid_in_layer  ! supplied gid projected to bottom layer
    integer(i_def)             :: depth         ! loop counter over halo depths
    integer(i_def)             :: start_search  ! start point for a search
    integer(i_def)             :: end_search    ! end point for a search
    integer(i_def)             :: num_in_list   ! total number of cells in partition
    integer(i_def)             :: num_halo      ! number of halo points already counted
    integer(i_def)             :: num_inner! number of inner halo points already counted

    num_in_list = self%num_edge
    do depth = 1,self%inner_depth
      num_in_list = num_in_list + self%num_inner(depth)
    end do
    do depth = 1,self%halo_depth
      num_in_list = num_in_list + self%num_halo(depth)
    end do

    ! Set the default return code
    lid = -1
    ! If the supplied gid is not valid just return
    if(gid < 1) return

    ! The global index lookup table (partitioned_cells) only has the indices for
    ! a single layer, so convert the full 3d global index into the global index
    ! within the layer and a layer number
    gid_in_layer = modulo(gid-1,self%global_num_cells) + 1
    nlayer = (gid-1) / self%global_num_cells

    ! Search though the inner halo cells - looking for the gid
    end_search = 0
    num_inner=0
    do depth = self%inner_depth, 1, -1
      start_search = end_search + 1
      end_search = start_search + self%num_inner(depth) - 1
      lid = binary_search( self%global_cell_id( start_search:end_search ), gid )
      if(lid /= -1)then
        lid = lid +  num_inner + nlayer*(num_in_list)  !convert back to 3d lid
        return
      end if
      num_inner = num_inner + self%num_inner(depth)
    end do

    ! Search though edge cells - looking for the gid
    start_search = end_search + 1
    end_search = start_search + self%num_edge - 1
    lid = binary_search( self%global_cell_id( start_search:end_search ), gid )
    if(lid /= -1)then
      lid = lid + num_inner + nlayer*(num_in_list)  !convert back to 3d lid
      return
    end if

    ! Search though halo and ghost cells - looking for the gid
    num_halo=0
    do depth = 1,self%halo_depth +1
      start_search = end_search + 1
      if(depth <= self%halo_depth) then
        end_search = start_search + self%num_halo(depth) - 1
      else
        end_search = start_search + self%num_ghost - 1
      end if
      lid = binary_search( self%global_cell_id( start_search:end_search ), gid )
      if(lid /= -1)then
        lid = lid + num_inner + self%num_edge + num_halo + &
                                    nlayer*(num_in_list)  !convert back to 3d lid
        return
      end if
      if(depth <= self%halo_depth) then
        num_halo = num_halo + self%num_halo(depth)
      end if
    end do

    ! No lid has been found in either the inner, edge or halo cells on this
    ! partition, so return with lid=-1
    return

  end function get_lid_from_gid

  !-------------------------------------------------------------------------------
  ! Performs a binary search through the given array. PRIVATE function.
  !-------------------------------------------------------------------------------
  ! Details: Performs a binary search through the given array looking for a
  !          particular entry and returns the index of the entry found or -1 if no
  !          matching entry can be found. The values held in "array_to_be_searched"
  !          must be in numerically increasing order.
  ! Input:   array_to_be_searched  The array that will be searched for the given entry
  !          value_to_find         The entry that is to be searched for
  !-------------------------------------------------------------------------------
  pure function binary_search( array_to_be_searched, value_to_find ) result ( id )

    implicit none

    integer(i_def), intent(in) :: array_to_be_searched( : )
    integer(i_def), intent(in) :: value_to_find
    integer(i_def)             :: bot, top  ! Lower and upper index limits between which to search for the value
    integer(i_def)             :: id        ! Next index for refining the search. If an entry is found this will
                                    ! contain the index of the matching entry

    ! Set bot and top to be the whole array to begin with
    bot = 1
    top = size(array_to_be_searched)

    search: do
      ! If top is lower than bot then there is no more array to be searched
      if(top < bot) exit search
      ! Refine the search
      id = (bot+top)/2
      if(array_to_be_searched(id) == value_to_find)then  ! found matching entry
        return
      else if(array_to_be_searched(id) < value_to_find)then ! entry has to be between id and top
        bot = id + 1
      else ! entry has to be between bot and id
        top = id - 1
      endif
    end do search

    ! Didn't find a match - return failure code
    id = -1

  end function binary_search

  !-------------------------------------------------------------------------------
  ! Performs a simple bubble sort on an array. PRIVATE function.
  !-------------------------------------------------------------------------------
  ! Details: Performs a bubble sort on an array of data.
  ! Input:   array  The array that will be sorted
  !          len  The length of the array to be sorted
  !-------------------------------------------------------------------------------
  subroutine bubble_sort(array, len)

    implicit none

    integer(i_def), intent(inout) :: array(:)
    integer(i_def), intent(in)    :: len

    logical(l_def) :: swapped
    integer(i_def) :: i
    integer(i_def) :: swap_temp

    do
      swapped = .false.
      do i = 1,len-1
        if(array(i) > array(i+1))then
          swap_temp = array(i)
          array(i) = array(i+1)
          array(i+1) = swap_temp
          swapped = .true.
        end if
      end do
      if( .not.swapped )exit
    end do

  end subroutine bubble_sort

end module partition_mod
