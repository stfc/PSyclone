# PSyclone for existing code - Tutorial 1 #

Welcome to the first part of the tutorial on using PSyclone with existing
Fortran code via its code-transformation capabilities. For this tutorial
we will be using a standalone, single-file mini-app (tra_adv.F90)
based on a tracer-advection routine that has been extracted from the full
source of the NEMO ocean model (www.nemo-ocean.eu). The original version of
this mini-app was kindly provided by Silvia Mocavero of CMCC.

## Prerequisites ##

The requirements for this section are as described in the practicals
[README.md](../../README.md#Requirements).

Check that PSyclone is installed and configured correctly by doing:

```bash
psyclone -h
```

When examining the PSyIR (the intermediate representation that PSyclone
uses to generate and translate code) and writing transformation
scripts, it may be useful to see the documentation of the various node
types. The best way to do this is to use the [PSyclone Reference Guide
](https://psyclone-ref.readthedocs.io/en/latest/).

## A note on importing PSyclone modules ##

Throughout these tutorials you will be working with PSyclone transformation
scripts written in Python. If you are adding functionality that requires
class definitions not already imported into the script then you will have
to add suitable import statements. e.g. to make the `Directive` node class
available you would add:

```python
from psyclone.psyir.nodes import Directive
```

All PSyIR node definitions are within the `psyclone.psyir.nodes` module
and all symbols and datatypes are within `psyclone.psyir.symbols`.

Unfortunately, the various transformation classes are not yet as well
organised. Many are now in the 'proper' location of
`psyclone.psyir.transformations`, but some are still in
`psyclone.transformations`. If in doubt, consult the
[Reference Guide](https://psyclone-ref.readthedocs.io/en/latest/_static/html/annotated.html).


## 1. Processing Fortran code with PSyclone ##

By default (i.e. without the additional arguments), the `psyclone` command
parses the provided input Fortran file:

```bash
psyclone tra_adv.F90
```

This command should result in PSyclone processing the supplied Fortran
and then re-generating it and writing it to stdout:

```fortran
PROGRAM tra_adv
   USE iso_c_binding, ONLY: C_INT64_T
   INTEGER, PARAMETER :: wp = 8
   ...
```

Since we have not specified any transformation yet, the generated code
is semantically equivalent to the input file, but with possibly a different
syntax. Also note that some statements have been marked with a "! PSyclone
 CodeBlock (unsupported code) reason:" comment. These are statements that
PSyclone does not understand the semantics of and (in most cases) will
avoid to transform.

In order to compile the Fortran that is generated by PSyclone, it needs
to be written to a file instead of stdout. This is achieved with the
`-o` flag.

```bash
psyclone tra_adv.F90 -o output.f90
```

will create a new file, `output.f90`, containing the generated Fortran
code. As it stands, this file does not contain standards-compliant
Fortran because it has a number of lines that are more than 132
characters in length. There are two possible solutions to this: tell
PSyclone that it must limit the length of output lines or tell your
Fortran compiler to allow non-standard line lengths. Since not all
Fortran compilers allow the line-length limit to be ignored, we
instruct PSyclone to limit the line lengths in the output Fortran via
the `-l output` flag:

```bash
psyclone tra_adv.F90 -o output.f90 -l output
```

(Note that if we also wanted PSyclone to validate that the *incoming*
code was standards compliant then we could specify `-l all` instead).

Then we can provide the generated file to a Fortran compiler. For example,
if we use `gfortran`, we can do:

```bash
gfortran output.f90 -o tra_adv.exe
```

The mini-app picks-up the domain size and number of iterations from
environment variables. The file `../domain_setup.sh` contains example
settings for bash and `../domain_setup.csh` is the equivalent if you are
using csh or tcsh. You can either cut-n-paste the commands into your
shell or do:

```bash
source ../domain_setup.sh
```

Once the environment variables are set, you are ready to execute the
mini-app:

```bash
./tra_adv.exe 
Tracer-advection Mini-app:
Domain is  100x 100 grid points
Performing   10 iterations
Mini-app finished.
```

At this point we have succeeded in processing some Fortran code
with PSyclone, generating new code and then compiling and running the
result. However, since we have not applied any transformations, the
generated code is functionally identical to that which was input.  In
order to apply transformations, we have to understand the Intermediate
Representation that PSyclone constructs for the supplied Fortran - the
PSyIR.

## 2. Obtaining the PSyIR ##

In order to examine the PSyIR for the mini-app we will supply PSyclone
with a transformation script, `view_trans.py`. This is done
via the `-s` flag to PSyclone.

```bash
psyclone tra_adv.F90 -s view_trans.py -o /dev/null | less
```

This should display a text representation of the tree of PSyIR nodes
that represent the `tra_adv.F90` file:

```bash
FileContainer[]
    Routine[name:'tra_adv']
        0: Call[name='get_environment_variable']
            Reference[name:'get_environment_variable']
            Literal[value:'JPI', Scalar<CHARACTER, UNDEFINED>]
            Reference[name:'env']
        ...
```

(Note that if you have the `termcolor` Python package installed
[`pip install termcolor`] then the PSyIR will be displayed with colour
highlighting.) Since the tracer-advection mini-app consists of a single
program unit, it is represented in PSyclone by a single `Routine` with the
content of the program (the sequence of executable statements) as children.


## 3. Interpreting the PSyIR ##

The basic structure and means of navigating the PSyIR are covered in the
[PSyIR - Tree navigation documentation](https://psyclone.readthedocs.io/en/latest/psyir.html#tree-navigation).
In summary, all nodes in the PSyIR have `parent` and `children`
properties and a `walk` method which may be used to find all nodes of
a given type (or types) below the current node. Various sub-classes of
Node also support semantic navigation. For instance, the Loop node has
`loop_body`, the If node has `condition`, `if_body` and `else_body`
and the Directive node has `directive_body`.

If you examine the PSyIR output for the mini-app, you will see that
the second child node of the `Routine` is a `CodeBlock`.
This is an important node type since it makes it possible
for the PSyIR to represent arbitrary Fortran code without requiring
that it be fully understood. Since PSyclone uses fparser2 to parse
Fortran, a `CodeBlock` stores the nodes of the underlying fparser2
parse tree that cannot be represented in the PSyIR. PSyclone treats
the CodeBlock as a blackbox that cannot be transformed, while still
allowing the transformation of any code outside the CodeBlock.

We can see from the fparser2 node type printed in the description of
the `CodeBlock` that this particular node represents a Fortran `READ`
statement. This is not computationally significant and therefore is not
interesting from a performance point of view.

To familiarise yourself with PSyIR navigation, you can:

1. Modify the transformation script so that it breaks-out into the Python
   debugger, pdb, as soon as it is called (from PSyclone):

   ```python
    def trans(psyir):
       import pdb; pdb.set_trace()
   ```

   Re-running PSyclone:

   ```bash
   psyclone -s ./view_trans.py tra_adv.F90
   ```
   will now launch the Python debugger at that point:

       -> print(psyir.view())
       (Pdb) 

   You can now interactively explore the PSyIR (passed to the routine via the
   `psyir` argument) and try the `walk` method, e.g.:

   ```python
    (Pdb) psyir
    <psyclone.psyir.nodes.file_container.FileContainer object at 0x7f4309023320>
    (Pdb) psyir.children
    [<psyclone.psyir.nodes.routine.Routine object at 0x7f4308dbd3d0>]
    (Pdb) pp psyir.children[0].children
    [<psyclone.psyir.nodes.call.Call object at 0x7f4308d16c00>,
     <psyclone.psyir.nodes.codeblock.CodeBlock object at 0x7f4308d24770>,
     <psyclone.psyir.nodes.call.Call object at 0x7f4308d938f0>,
     ... ]
    (Pdb) from psyclone.psyir.nodes import Loop
    (Pdb) loops = psyir.walk(Loop)
    (Pdb) [loop.variable.name for loop in loops]
    ['jk', 'jj', 'ji', 'jj', 'ji', 'jk', 'jt', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji', 'jk', 'jj', 'ji']
   ```

   (Once you are done you can *quit the debugger* by doing `Ctrl-d` or
   by entering the `quit()` command.)

2. Modify the transformation script so that it uses `walk` to search
   for all of CodeBlocks in the file and prints information
   about each of them. Work out which lines of Fortran in the
   mini-app each corresponds to. (All nodes have a `debug_string()`
   method to quickly print the node and its children.)

    ```python
    from psyclone.psyir.nodes import CodeBlock
    for cb in psyir.walk(CodeBlock):
        print(cb.debug_string())
    ```

For now we note that since, by definition, PSyclone does not
understand the contents of a CodeBlock, it is not possible (with the
exception of profiling) to apply transformations to regions of code
that contain them.

From a computational-performance standpoint, the most important nodes
are [`Loop`](https://psyclone-ref.readthedocs.io/en/latest/_static/html/classpsyclone_1_1psyir_1_1nodes_1_1loop_1_1Loop.html) and
[`Assignment`](https://psyclone-ref.readthedocs.io/en/latest/_static/html/classpsyclone_1_1psyir_1_1nodes_1_1assignment_1_1Assignment.html).

3. Modify the transformation script to obtain a list of all of the
   `Assignment` nodes:

   ```python
   from psyclone.psyir.nodes import Assignment
   assignments = psyir.walk(Assignment)
   ```

4. Use the `view()` method of one of these `Assignment` nodes to
   examine its children. Check that you are able to work out
   which Fortran assignment this corresponds to, e.g.:

   ```python
   print(assignments[0].view())
   ```

   As mentioned earlier, the `debug_string` method can also be very
   useful:

   ```python
   print(assignments[0].debug_string())
   ```

## 4. Conclusion

Congratulations, you have now completed this section of the tutorial.
At this point you should be able to run PSyclone on a Fortran source
file, use a transformation script to access the PSyIR of the code and
be able to understand the structure of the PSyIR and how it relates to
the original Fortran.

You may now proceed to the [second section](../2_profiling/README.md)
of the tutorial where you will use PSyclone to add profiling instrumentation
to the mini-app.
