.. -----------------------------------------------------------------------------
.. BSD 3-Clause License
..
.. Copyright (c) 2019-2020, Science and Technology Facilities Council.
.. All rights reserved.
..
.. Redistribution and use in source and binary forms, with or without
.. modification, are permitted provided that the following conditions are met:
..
.. * Redistributions of source code must retain the above copyright notice, this
..   list of conditions and the following disclaimer.
..
.. * Redistributions in binary form must reproduce the above copyright notice,
..   this list of conditions and the following disclaimer in the documentation
..   and/or other materials provided with the distribution.
..
.. * Neither the name of the copyright holder nor the names of its
..   contributors may be used to endorse or promote products derived from
..   this software without specific prior written permission.
..
.. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.. "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.. LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
.. FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
.. COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
.. INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
.. BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
.. LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
.. CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.. LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
.. ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.. POSSIBILITY OF SUCH DAMAGE.
.. -----------------------------------------------------------------------------
.. Written by R. W. Ford, A. R. Porter and S. Siso STFC Daresbury Lab

The PSyclone Internal Representation (PSyIR)
############################################

The PSyclone Intermediate Representation (PSyIR) is a language-independent
Intermediate Representation that PSyclone uses to represent the PSy (Parallel
System) and the Kernel (serial units of work) layers of an application that
can be constructed from scratch or produced from existing code using one of
the PSyIR front-ends. Its design is optimised to represent high-performance
parallel applications in an expressive, mutable and extensible way:

 - It is **expressive** because it is intended to be created and/or manipulated
   by HPC software experts directly when optimizing or porting the code.

 - It is **mutable** because it is intended to be programmatically manipulated
   (usually though PSyclone scripts) and maintain a coherent state (with
   valid relationships, links to symbols, links to dependencies) after each
   manipulation.

 - It is **extensible** because it is intended to be used as the core component
   of domain-specific systems which include additional abstract concepts
   or logic not captured in the generic representation.

To achieve these design goals we use a Normalised Heterogeneous AST
representation together with a Type System and a Symbol Table.
By **heterogeneous** we mean that we distinguish between AST nodes using
Python class inheritance system and each node has its particular (and
semantically relevant) navigation and behaviour methods. For instance the
``Assignment`` node has ``lhs`` and ``rhs`` properties to navigate to the
left-hand-side and right-hand-side operators of the Assignment. It also
means we can indentify a node using its type with
``isinstance(node, Assignment)``.
Nevertheless, we maintain a **normalised** core of node relationships and
functionality that allows us to build tree walkers, tree visitors and
dependency analysis tools without the need to consider the implementation
details of each individual sub-class.

The common functionality that all nodes must have is defined in the
PSyIR base class `Node`.
See the list of all PSyIR common methods in the 
`Node reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Node>`_.

More information about the type system and symbols and how PSyIR
can be transformed back to a particular language using the back-ends
(Writers) is provided in the following sections of this guide.


.. _newnodes-label:

How to create new PSyIR Nodes
=============================
In order to create a new PSyIR node, either for adding a new core PSyIR node
or to extend the functionality in one of the PSyclone APIs, it is mandatory
to perform the following steps: 

1. The new node must inherit from ``psyclone.psyir.nodes.Node`` or one of its
   sub-classes. Note that ``Node`` won't be accepted as a child anywhere in
   the tree. It may be appropriate to specialise one of the existing
   subclasses of Node, rather than Node itself.
   A good starting point would be to consider
   ``psyclone.psyir.nodes.Statement`` (which will be accepted inside any
   Schedule) or ``psyclone.psyir.nodes.DataNode`` (which will be accepted
   anywhere that the node can be evaluated to a data element). 

2. Set the ``_text_name`` and the ``_color_key`` class string attributes. These
   attributes will provide standard behaviour for the ``__str__`` and
   ``view()`` methods.

3. Set the ``_children_valid_format`` class string attribute and specialise
   the static method ``_validate_child(position, child)``. These define,
   textually and logically, what types of nodes will be accepted as children
   of the new node:

    - ``_children_valid_format`` is the textual representation that will be
      used in error messages. It is expressed using tokens with the same name
      as the PSyIR classes and the following symbols:

        - ``|``: or operand.

        - ``,``: concatenation operand.

        - ``[ expression ]*``: zero or more instances of the expression.

        - ``[ expression ]+``: one or more instances of the expression.

        - ``<LeafNode>``: NULL operand (no children accepted).

      For instance, an expression that accepts a statement as a first child and
      one or more DataNodes after it would be: ``Statement [, DataNode]+``.


    - ``_validate_child(position, child)`` returns a boolean which indicates
      whether the given child is a valid component for the given position.

.. note:: Note that the valid children of a node are described two times, once in
    ``_children_valid_format`` and another in ``_validate_child``, and it is
    up to the developer to keep them coherent in order to provide sensible
    error messages. Alternatively we could create an implementation where
    the textual representation is parsed and the validation method is
    generated automatically, hence avoiding the duplication. Issue #765
    explores this alternative.

For example, if we want to create a node that can be found anywhere where a
statement is valid, and in turn it accepts one and only one DataNode as a
child, we would write something like:


    .. literalinclude:: code_snippets/newnode.py
        :language: python
        :lines: 47-60

This implementation already provides the basic PSyIR functionality and the
node can be integrated and used in the PSyIR tree:

::

    >>> mynode = MyNode(children=[Literal("1", INTEGER_TYPE)])

    >>> mynode.children.append(Literal("2", INEGER_TYPE))
    ...
    psyclone.errors.GenerationError: Generation Error: Item 'Literal' can't be
    child 1 of 'MyNodeName'. The valid format is: 'DataNode'.

    >>> schedule.addchild(mynode)

    >>> schedule.view()
    Schedule[]
        MyNodeName[]
                Literal[value:'1', Scalar<INTEGER, UNDEFINED>]

For a full list of methods available in any PSyIR node see the
`Node reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Node>`_.

.. note:: For convenience, the PSyIR children validation is performed
    with both: Node methods (e.g. ``node.addchild()``) and also list
    methods (e.g. ``node.children.extend([node1, node2])``).

    To achieve this, we sub-classed the Python list and redefined all
    methods that modify the list by calling first the PSyIR provided
    validation method and subsequently, if valid, calling the associated
    list method.

.. _nodesinfo-label:

Selected Node Descriptions
==========================

.. _container-label:

Container
---------

The Container node contains one or more Containers and/or
KernelSchedules (see :ref:`kernel_schedule-label`). Similarly to
KernelSchedule it contains a SymbolTable
(`psyclone.psyGen.psyir.symbols.SymbolTable`) that keeps a record of
the Symbols (`psyclone.psyGen.psyir.symbols.Symbol`) specified in the
Container scope (see :ref:`user_guide:symbol-label`).

A Container can be used to capture a hierarchical grouping of
KernelSchedules and a hierarchy of Symbol scopes i.e. a Symbol
specified in a Container is visible to all Containers and
KernelSchedules within it and their descendants.
See the full Container API in the
`Container reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Container>`_.


Schedule
--------

The Schedule node represents a sequence of statements. It is an important node
in PSyclone because two of its specialisations: `InvokeSchedule` and
`KernelSchedule` (described below), are used as the root nodes of PSy-layer
invokes and kernel subroutines. This makes them the starting points for any
walking of the PSyIR tree in PSyclone transformation scripts and a common
target for the application of transformations.
See the full Schedule API in the
`Schedule reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Schedule>`_.


InvokeSchedule
^^^^^^^^^^^^^^

The `InvokeSchedule` is a PSyIR node that represents an invoke subroutine in
the PSy-layer. It extends the `psyclone.psyir.nodes.Schedule` functionality
with a `psyclone.psyir.symbols.SymbolTable` and a reference to its associated
`psyclone.psyGen.Invoke` object.


.. _kernel_schedule-label:

KernelSchedule
^^^^^^^^^^^^^^

The `KernelSchedule` is a PSyIR node that represents a kernel
subroutine. It extends the `psyclone.psyir.nodes.Schedule` functionality
with a SymbolTable (`psyclone.psyGen.psyir.symbols.SymbolTable`) that
keeps a record of the Symbols (`psyclone.psyGen.psyir.symbols.Symbol`)
used in the kernel scope (see :ref:`user_guide:symbol-label`).


Control Flow Nodes
------------------

The PSyIR has two control flow nodes: `IfBlock` and `Loop`. These
nodes represent the canonical structure with which conditional
branching constructs and iteration constructs are built. Additional
language-specific syntax for branching and iteration will be
normalised to use these same constructs.  For example, Fortran has the
additional branching constructs `ELSE IF` and `CASE`: when a Fortran
code is translated into the PSyIR, PSyclone will build a semantically
equivalent implementation using `IfBlocks`.  Similarly, Fortran also
has the `WHERE` construct and statement which are represented in the
PSyIR with a combination of `Loop` and `IfBlock` nodes. Such nodes in
the new tree structure are annotated with information to enable the
original language-specific syntax to be recreated if required (see
below).
See the full IfBlock API in the
`IfBlock reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.IfBlock>`_
and Loop API in 
`Loop reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Loop>`_.

Control Flow Node annotation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the PSyIR is constructed from existing code (using e.g. the
fparser2 frontend) then it is possible that information about that
code may be lost.  This is because the PSyIR is only semantically
equivalent to certain code constructs. In order that information is
not lost (making it possible to e.g. recover the original code
structure if desired) Nodes may have `annotations` associated with
them. The annotations, the Node types to which they may be applied and
their meanings are summarised in the table below:

=================  =================  =================================
Annotation         Node types         Origin
=================  =================  =================================
`was_elseif`       `IfBlock`          `else if`
`was_single_stmt`  `IfBlock`, `Loop`  `if(logical-expr)expr` or Fortran
                                      `where(array-mask)array-expr`
`was_case`         `IfBlock`          Fortran `select case`
`was_where`        `Loop`, `IfBlock`  Fortran `where` construct
=================  =================  =================================

.. note:: a `Loop` may currently only be given the `was_single_stmt` annotation
	  if it also has the `was_where` annotation. (Thus indicating that
	  this `Loop` originated from a WHERE *statement* in the original
	  Fortran code.) Representing single-statement loops in Fortran is
	  the subject of GitHub Issue
	  `#412 <https://github.com/stfc/PSyclone/issues/412>`_.

Ranges
------

The PSyIR has the `Range` node which represents a range of integer
values with associated start, stop and step properties. e.g. the list
of values [4, 6, 8, 10] would be represented by a `Range` with a start
value of 4, a stop value of 10 and a step of 2 (all stored as `Literal`
nodes). This class is intended to simplify the construction of Loop nodes
as well as to support array slicing (see below). However, this
functionality is under development and at this stage neither of those
options have been implemented.

The `Range` node must also provide support for array-slicing
constructs where a user may wish to represent either the entire range
of possible index values for a given dimension of an array or a
sub-set thereof. e.g. in the following Fortran::

    real, dimension(10, 5) :: my_array
    call some_routine(my_array(1, :))

the argument to `some_routine` is specified using array syntax where
the lone colon means *every* element in that dimension. In the PSyIR,
this argument would be represented by an `Array` node with the first
entry in its `shape` being an integer `Literal` (with value 1) and the
second entry being a `Range`. In this case the `Range` will have a
start value of `LBOUND(my_array, 1)`, a stop value of
`UBOUND(my_array, 1)` and a step of `Literal("1")`. Note that `LBOUND`
and `UBOUND` are not yet implemented (Issue #651) but will be
instances of `BinaryOperation`. (For the particular code fragment
given above, the values are in fact known [1 and 5, respectively] and
could be obtained by querying the Symbol Table.)

See the full Range API in the
`Range reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Range>`_.

Operation Nodes
---------------

Arithmetic operations and various intrinsic/query functions are represented
in the PSyIR by sub-classes of the `Operation` node. The operations are
classified according to the number of operands:

- Those having one operand are represented by
  `psyclone.psyir.nodes.UnaryOperation` nodes,

- those having two operands are represented by
  `psyclone.psyir.nodes.BinaryOperation` nodes.

- and those having more than two or a variable number of operands are
  represented by `psyclone.psyir.nodes.NaryOperation` nodes.

See the documentation for each Operation class in the
`Operation <https://psyclone-ref.readthedocs.io/en/latest/autogenerated/
psyclone.psyir.nodes.html#psyclone.psyir.nodes.Operation>`_,
`UnaryOperation <https://psyclone-ref.readthedocs.io/en/latest/autogenerated/
psyclone.psyir.nodes.html#psyclone.psyir.nodes.UnaryOperation>`_,
`BinaryOperation <https://psyclone-ref.readthedocs.io/en/latest/autogenerated/
psyclone.psyir.nodes.html#psyclone.psyir.nodes.BinaryOperation>`_ and
`NaryOperation <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.NaryOperation>`_
sections of the reference guide.

Note that where an intrinsic (such as
Fortran's `MAX`) can have a variable number of arguments, the class
used to represent it in the PSyIR is determined by the actual number
of arguments in a particular instance. e.g. `MAX(var1, var2)` would be
represented by a `psyclone.psyir.nodes.BinaryOperation` but `MAX(var1,
var2, var3)` would be represented by a
`psyclone.psyir.nodes.NaryOperation`.

CodeBlock Node
--------------

The PSyIR CodeBlock node contains code that has no representation in
the PSyIR. It is useful as it allows the PSyIR to represent complex
code by using CodeBlocks to handle the parts which contain unsupported
language features. One approach would be to work towards capturing all
language features in the PSyIR, which would gradually remove the need
for CodeBlocks. However, the purpose of the PSyIR is to capture code
concepts that are relevant for performance, not all aspects of a code,
therefore it is likely that CodeBlocks will continue to be an
important part of the PSyIR.
See the full Codeblock API in the
`CodeBlock reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.CodeBlock>`_.

The code represented by a CodeBlock is currently stored as a list of
fparser2 nodes. Therefore, a CodeBlock's input and output language is
limited to being Fortran. This means that only the fparser2 front-end
and Fortran back-end can be used when there are CodeBlocks within a
PSyIR tree. In theory, language interfaces could be written between
CodeBlocks and other PSyIR Nodes to support different back-ends but
this has not been implemented.

Currently PSyIR have a single CodeBlock node that can be found
in place of full Statements or being part of an expression that
evaluates to a DataNode. To make this possible CodeBlock is a subclass
of both: Statement and DataNode. However, in certain situations we
still need to differentiate which one it is, for instance the Fortran
back-end needs this information, as expressions do not need indentation
and a newline whereas statements do.
For this reason, CodeBlock has a ``structure`` method that indicates
whether the code contains one or more unrecognized language expressions
or one or more statements (which may themselves contain expressions).

The Fortran front-end populates the ``structure`` attribute using a
feature of the fparser2 node list that is if the first node in the
list is a statement then so are all the other nodes in the list and
that if the first node in the list is an expression then so are all
the other nodes in the list. This allows the ``structure`` method to
return a single value that represents all nodes in the list.
The structure of the PSyIR hierarchy is used to determine whether the
code in a CodeBlock contains expressions or statements. This is
achieved by looking at the parent PSyIR Node. If the parent Node is a
Schedule then the CodeBlock contains one or more statements, otherwise
it contains one or more expressions.

This logic works for existing PSyIR nodes and relies on any future PSyIR
nodes being constructed so this continues to be true. Another solution
would be to have two different nodes: StatementsCodeBlock which subclasses
Statement, and DataCodeBlock which subclasses DataNode. We have chosen the
first implementation for the simplicity of having a single PSyIR node instead
of two, but if things get more complicated using this implementation, the
second alternative could be considered again.

Reference Node
--------------

The PSyIR Reference Node represents a scalar variable access. It keeps
a reference to a Symbol which will be stored in a symbol table.
See the full Reference API in the
`Reference reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Reference>`_.

Array Node
----------

The PSyIR Array Node represents an array access. It keeps a reference
to a Symbol which will be stored in a
symbol table and the indices used to access the array. Array Node
inherits from Reference Node.
See the full Array API in the
`Array reference guide <https://psyclone-ref.readthedocs.io/en/latest/
autogenerated/psyclone.psyir.nodes.html#psyclone.psyir.nodes.Array>`_.
