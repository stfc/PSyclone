! BSD 3-Clause License
!
! Copyright (c) 2020-2025, Science and Technology Facilities Council
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! -----------------------------------------------------------------------------
! Author: J. Henrichs, Bureau of Meteorology
! Modifications: A. R. Porter, STFC Daresbury Laboratory
!                J. Dendy, Met Office

program main

    use global_mesh_mod,        only : global_mesh_type
    use lfric_ncdf_file_mod,    only : lfric_ncdf_file_type

    use local_mesh_mod,         only: local_mesh_type
    use local_mesh_collection_mod, only: local_mesh_collection, local_mesh_collection_type
    use mesh_collection_mod,    only: mesh_collection, mesh_collection_type
    use halo_routing_collection_mod,   only: halo_routing_collection_type,   &
                                           halo_routing_collection
    use function_space_collection_mod, only: function_space_collection_type, &
                                           function_space_collection
    use driver_collections_mod, only: init_collections

    use mesh_mod,               only: mesh_type, PLANE
    use partition_mod,          only: partition_type, partitioner_planar, partitioner_interface
    use extrusion_mod,          only: extrusion_type, uniform_extrusion_type
    use function_space_collection_mod, only: function_space_collection
    use function_space_mod,     only: function_space_type
    use fs_continuity_mod,      only: W0, W1, W2, W2V, W2H
    use field_mod,              only: field_type, field_proxy_type
    use field_real64_mod,      only : field_real64_type
    use testkern_w0_kernel_mod, only: testkern_w0_kernel_type
    use constants_mod,          only: r_def, i_def, str_def
    use log_mod,                only: initialise_logging
    use ugrid_mesh_data_mod, only: ugrid_mesh_data_type

    implicit none

    type(lfric_ncdf_file_type), target         :: global_netcdf_mesh
    type(global_mesh_type), target             :: global_mesh
    type(local_mesh_type), target              :: local_mesh
    type(partition_type)                       :: partition
    type(mesh_type), target                    :: mesh
    type(uniform_extrusion_type), target       :: extrusion
    type(function_space_type), target          :: vector_space
    type(function_space_type), pointer         :: vector_space_ptr
    procedure (partitioner_interface), pointer :: partitioner_ptr
    type(field_type), target                   :: field1, field2
    type(field_proxy_type)                     :: field1_proxy
    integer(kind=i_def)                        :: lfric_fs = W0   ! W0
    integer(kind=i_def)                        :: element_order_h = 1
    integer(kind=i_def)                        :: element_order_v = 1
    integer(kind=i_def)                        :: ndata_sz, mesh_id
    character(str_def) :: name="123"
    real*8  :: field_min_norm
    type(ugrid_mesh_data_type) :: ugrid_mesh_data

    ! This function is not part of the actual infrastructure
    call init_collections()

    ! Enable logging
    call initialise_logging(0,                        & ! communicator - ignored
                            "log",                    & ! filename
                            trace_on_warnings=.true., &
                            log_to_rank_zero_only=.false.)

    call ugrid_mesh_data%read_from_file("mesh_BiP128x16-400x100.nc", &
                                        "dynamics")
    global_mesh = global_mesh_type( ugrid_mesh_data )

    partitioner_ptr => partitioner_planar
    partition = partition_type(global_mesh,     &
                               partitioner_ptr, &
                               1, 1,    &    ! # procs in x and y direction
                               1,       &    ! max stencil size
                               .false., &    ! generate_inner_haloes
                               0,       &    ! local rank
                               1)            ! number of proceses

    ! Creating a vertical mesh of height 100 m with 5 layers
    ! It is important to use 0.0_r_def, otherwise:
    ! Error: Component ‘atmosphere_bottom’ at (1) is a PRIVATE component of ‘extrusion_type’
    ! Because it tries to use the Fortran default constructor to assign individual components

    ! The last parameter is the extrusion id, which we don't need otherwise
    extrusion = uniform_extrusion_type(0.0_r_def, 100.0_r_def, 5, 1)
    name = "test123"
    mesh = mesh_type(local_mesh, extrusion, mesh_name=name)
    mesh_id = mesh_collection%add_new_mesh(mesh)
    write (*,*) "Mesh has", mesh%get_nlayers(), "layers."
    ndata_sz = 1
    vector_space = function_space_type( mesh%get_id(),   &
                                        element_order_h, &
                                        element_order_v, &
                                        lfric_fs,        &
                                        ndata_sz)
    vector_space_ptr => vector_space
    call field1%initialise( vector_space = vector_space_ptr, name="field1" )
    call field2%initialise( vector_space = vector_space_ptr, name="field2" )
    call invoke( name = 'Initialise_fields',        &
                 setval_c( field1,     0.0_r_def ), &
                 setval_c( field2,     1.0_r_def )  &
                 )
    call invoke( name = 'testkern_w0', testkern_w0_kernel_type(field1, field2) )

    field1_proxy = field1%get_proxy()
    field_min_norm = field1_proxy%get_min()
    print *,"minmax of field1", field1_proxy % get_min(), field1_proxy % get_max()!


end program main
