! BSD 3-Clause License
!
! Copyright (c) 2020-2025, Science and Technology Facilities Council
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are met:
!
! * Redistributions of source code must retain the above copyright notice, this
!   list of conditions and the following disclaimer.
!
! * Redistributions in binary form must reproduce the above copyright notice,
!   this list of conditions and the following disclaimer in the documentation
!   and/or other materials provided with the distribution.
!
! * Neither the name of the copyright holder nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! -----------------------------------------------------------------------------
! Author: J. Henrichs, Bureau of Meteorology
! Modifications: A. R. Porter, STFC Daresbury Laboratory
!                J. Dendy, Met Office

program main
    !> This program is a simple LFRic program that contains two invokes,
    !> the first to initialise a few fields, the second to update a field.
    !> It can be used with kernel extraction for both invokes. After
    !> instrumenting the code using PSyclone with the extract_transform.py
    !> script, it can be compiled, and when executed will create two kernel data
    !> files. The instrumentation will also create two stand-alone driver
    !> programs, which can be compiled. They will each read the corresponding
    !> kernel data file, execute the kernel, and compare the results.

#ifdef _MPI
    use mpi
#endif

    use global_mesh_mod,        only: global_mesh_type
    use mesh_mod,               only: mesh_type, PLANE
    use local_mesh_mod,         only: local_mesh_type
    use local_mesh_collection_mod, only: local_mesh_collection, local_mesh_collection_type
    use mesh_collection_mod,    only: mesh_collection, mesh_collection_type
    use halo_routing_collection_mod,   only: halo_routing_collection_type,   &
                                           halo_routing_collection
    use function_space_collection_mod, only: function_space_collection_type, &
                                           function_space_collection
    use driver_collections_mod, only: init_collections

    use partition_mod,          only: partition_type, partitioner_planar, partitioner_interface
    use extrusion_mod,          only: extrusion_type, uniform_extrusion_type
    use function_space_mod,     only: function_space_type
    use function_space_collection_mod, only: function_space_collection
    use fs_continuity_mod,      only: W0, W1, W2, W2V, W2H
    use field_mod,              only: field_type, field_proxy_type
    use field_real64_mod,      only : field_real64_type
    use testkern_w0_kernel_mod, only: testkern_w0_kernel_type
    use constants_mod,          only: r_def, i_def, str_def, l_def
    use log_mod,                only: initialise_logging

    implicit none

    type(global_mesh_type), target             :: global_mesh
    type(global_mesh_type), pointer            :: global_mesh_ptr
    type(partition_type)                       :: partition
    type(mesh_type), target                    :: mesh
    type(local_mesh_type), target              :: local_mesh
    type(local_mesh_type), pointer             :: local_mesh_ptr
    type(uniform_extrusion_type), target       :: extrusion
    class(extrusion_type), pointer             :: extrusion_ptr
    type(function_space_type), target          :: vector_space
    type(function_space_type), pointer         :: vector_space_ptr
    procedure (partitioner_interface), pointer :: partitioner_ptr
    type(field_type), target                   :: field1, field2
    type(field_proxy_type)                     :: field1_proxy
    integer(kind=i_def)                        :: lfric_fs = W0   ! W0
    integer(kind=i_def)                        :: element_order_h = 1
    integer(kind=i_def)                        :: element_order_v = 1
    integer(kind=i_def)                        :: ndata_sz, mesh_id
    character(str_def) :: name="123"
    real*8  :: field_min_norm

    type(field_type)                           :: chi(3)
    real(kind=r_def)                           :: one
    logical(kind=l_def)                        :: some_logical
    integer                                    :: i, ierr



#ifdef _MPI
    call MPI_Init(ierr)
#endif

    call init_collections()

    ! Enable logging
    call initialise_logging(0,                        & ! communicator - ignored
                            "log",                    & ! filename
                            trace_on_warnings=.true., &
                            log_to_rank_zero_only=.false.)

    ! Use the unit-testing constructor:
    global_mesh = global_mesh_type()
    global_mesh_ptr => global_mesh

    partitioner_ptr => partitioner_planar
    ! Note: stencil size must be 1, otherwise the constructor
    ! crashes when allocation a 0-size array
    partition = partition_type(global_mesh_ptr, &
                               partitioner_ptr, &
                               1, 1,    &    ! # procs in x and y direction
                               1,       &    ! max stencil size
                               .false., &    ! generate_inner_haloes
                               0,       &    ! local rank
                               1)          ! number of processes
    call local_mesh%initialise( global_mesh_ptr, partition )
    call local_mesh%init_cell_owner()
    local_mesh_ptr => local_mesh

    ! Creating a vertical mesh of height 100 m with 5 layers
    ! It is important to use 0.0_r_def, otherwise:
    ! Error: Component ‘atmosphere_bottom’ at (1) is a PRIVATE component of ‘extrusion_type’
    ! Because it tries to use the Fortran default constructor to assign individual components
    ! The last parameter is the extrusion id, which we do not need otherwise
    extrusion = uniform_extrusion_type(0.0_r_def, 100.0_r_def, 5, 1)
    extrusion_ptr => extrusion

    name = "test123"
    mesh = mesh_type(local_mesh_ptr, extrusion, mesh_name=name)
    mesh_id = mesh_collection%add_new_mesh(mesh)
    write (*,*) "Mesh has", mesh%get_nlayers(), "layers."
    ndata_sz = 1
    vector_space = function_space_type( mesh%get_id(),            &
                                        element_order_h, &
                                        element_order_v, &
                                        lfric_fs,        &
                                        ndata_sz)
    vector_space_ptr => vector_space

    do i=1, 3
        call chi(i)%initialise( vector_space = vector_space_ptr, name="chi" )
    enddo

    call field1%initialise( vector_space = vector_space_ptr, name="field1" )
    call field2%initialise( vector_space = vector_space_ptr, name="field2" )

    one = 1.0_r_def

    call invoke( name = 'Initialise_fields',        &
                 setval_c( field1,     0.0_r_def ), &
                 setval_c( field2,     one)         &
                 )
    call invoke( name = 'testkern_w0', testkern_w0_kernel_type(field1, field2, &
                                                               chi,            &
                                                               some_logical) )

    field1_proxy = field1%get_proxy()
        field_min_norm = field1_proxy%get_min()

    print *,"minmax of field1", field1_proxy % get_min(), field1_proxy % get_max()!

#ifdef _MPI
    call MPI_Finalize(ierr)
#endif

end program main
